{# templates/plant/heat_toggle.html #}
{% extends "parent.html" %}
{% block content %}
<div class="container mt-4">
    <h1 class="mb-4">Heat Breaks Toggle</h1>
        
    <!-- Back to app button -->
    <a href="{% url 'maintenance_all' %}" class="btn btn-warning mb-3">
      ‚Üê Back to app
    </a>

    <p>Toggling heat breaks on and off will automatically generate entries in the downtime app</p>

    <div class="accordion" id="linesAccordion">
        {% for line, machines in grouped_data.items %}
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading-{{ forloop.counter }}">
                    <button class="accordion-button {% if not forloop.first %}collapsed{% endif %}"
                            type="button"
                            data-bs-toggle="collapse"
                            data-bs-target="#collapse-{{ forloop.counter }}"
                            aria-expanded="{% if forloop.first %}true{% else %}false{% endif %}"
                            aria-controls="collapse-{{ forloop.counter }}">
                        {{ line }}
                    </button>
                </h2>
                <div id="collapse-{{ forloop.counter }}"
                     class="accordion-collapse collapse {% if forloop.first %}show{% endif %}"
                     aria-labelledby="heading-{{ forloop.counter }}"
                     data-bs-parent="#linesAccordion">
                    <div class="accordion-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-bordered align-middle">
                                <thead class="table-dark">
                                    <tr>
                                        <th>Operation</th>
                                        <th>Machine #</th>
                                        <th>Heat Break</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for machine in machines %}
                                        {# Carry the active state as data attributes on the row #}
                                        <tr
                                            id="row-{{ machine.id }}"
                                            data-machine="{{ machine.id }}"
                                            {% if machine.active_hb %}
                                                data-active-hb-id="{{ machine.active_hb.id }}"
                                                data-active-duration="{{ machine.active_hb.duration }}"
                                                data-start-time-iso="{{ machine.active_hb.start_time_iso }}"
                                            {% endif %}
                                            >

                                            <td>{{ machine.operation }}</td>
                                            <td>{{ machine.machine_number }}</td>
                                            <td>
                                                <div class="d-flex flex-wrap align-items-center gap-3">
                                                    {# "No heat break" default radio #}
                                                    <div class="form-check form-check-inline">
                                                        <input class="form-check-input toggle-radio"
                                                               type="radio"
                                                               name="toggle-{{ machine.id }}"
                                                               id="toggle-{{ machine.id }}-none"
                                                               value="none"
                                                               data-machine="{{ machine.id }}">
                                                        <label class="form-check-label"
                                                               for="toggle-{{ machine.id }}-none">No heat break</label>
                                                    </div>

                                                    {# Existing duration radios #}
                                                    {% for mins in durations %}
                                                        <div class="form-check form-check-inline">
                                                            <input class="form-check-input toggle-radio"
                                                                   type="radio"
                                                                   name="toggle-{{ machine.id }}"
                                                                   id="toggle-{{ machine.id }}-{{ mins }}"
                                                                   value="{{ mins }}"
                                                                   data-machine="{{ machine.id }}">
                                                            <label class="form-check-label"
                                                                   for="toggle-{{ machine.id }}-{{ mins }}">{{ mins }} min</label>
                                                        </div>
                                                    {% endfor %}
                                                </div>
                                            </td>
                                        </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        {% empty %}
            <p>No tracked machines found.</p>
        {% endfor %}
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="offModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <form id="offForm" method="post">
      {% csrf_token %}
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Confirm Heat Break End</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <p>The heat break was between:</p>
          <div class="mb-3">
            <label class="form-label">Start Time</label>
            <input type="datetime-local" class="form-control" name="start_time" id="offStart" readonly>
          </div>
          <div class="mb-3">
            <label class="form-label">End Time</label>
            <input type="datetime-local" class="form-control" name="end_time" id="offEnd">
            <div id="offEndFeedback" class="invalid-feedback">
                End time cannot be before the start time.
            </div>
            </div>
          <input type="hidden" name="heatbreak_id" id="heatbreakId">
          <input type="hidden" id="offMachineId">
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-dark" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn btn-warning">Confirm</button>
        </div>
      </div>
    </form>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // ---------- constants / selectors ----------
  const ROW_SELECTOR = "tr[id^='row-']";
  const RADIO_SELECTOR = ".toggle-radio";
  const MODAL_ID = "offModal";
  const FORM_ID = "offForm";
  const ACTIVE = new Map(); // machineId -> { hbId, startIso, duration }

  // ---------- helpers ----------
  const pad2 = (n) => String(n).padStart(2, "0");

  // Format a Date into YYYY-MM-DDTHH:MM for <input type="datetime-local">
  function formatForDatetimeLocal(d) {
    return [
      d.getFullYear(), "-", pad2(d.getMonth() + 1), "-", pad2(d.getDate()),
      "T", pad2(d.getHours()), ":", pad2(d.getMinutes())
    ].join("");
  }

  // Convert an ISO string (with tz) into local datetime-local string
  function isoToLocalInput(iso) {
    try {
      const d = new Date(iso);
      return isNaN(d.getTime()) ? "" : formatForDatetimeLocal(d);
    } catch { return ""; }
  }

  // Parse a datetime-local string as LOCAL time
  function parseLocalInput(str) {
    if (!str || !str.includes("T")) return null;
    const [datePart, timePart] = str.split("T");
    const [y, m, d] = datePart.split("-").map(Number);
    const [hh, mm]  = timePart.split(":").map(Number);
    const dt = new Date(y, (m || 1) - 1, d || 1, hh || 0, mm || 0, 0, 0);
    return isNaN(dt.getTime()) ? null : dt;
  }

  function selectRadio(machineId, value) {
    const el = document.getElementById(`toggle-${machineId}-${value}`);
    if (el) el.checked = true;
  }
  const selectNone = (machineId) => selectRadio(machineId, "none");

  function setEndInvalid(isInvalid, message) {
    const endInput = document.getElementById("offEnd");
    const feedback = document.getElementById("offEndFeedback");
    if (!endInput) return;
    endInput.classList.toggle("is-invalid", !!isInvalid);
    if (feedback && message) feedback.textContent = message;
  }

  function getCsrfToken() {
    // Using the rendered token passed in headers (kept from your original code)
    return "{{ csrf_token }}";
  }

  // ---------- initialize UI from server-emitted data-* ----------
  document.querySelectorAll(ROW_SELECTOR).forEach((row) => {
    const machineId = row.dataset.machine;
    const hbId      = row.dataset.activeHbId || null;
    const duration  = row.dataset.activeDuration || null;
    const startIso  = row.dataset.startTimeIso || null;

    if (hbId && duration) {
      ACTIVE.set(machineId, { hbId, startIso, duration });
      selectRadio(machineId, duration);
    } else {
      selectNone(machineId);
    }
  });

  // ---------- open modal for "end heat break" ----------
  function openOffModal(machineId, active) {
    const offStart = document.getElementById("offStart");
    const offEnd   = document.getElementById("offEnd");
    const hbIdEl   = document.getElementById("heatbreakId");
    const midEl    = document.getElementById("offMachineId");
    const modalEl  = document.getElementById(MODAL_ID);

    if (!offStart || !offEnd || !hbIdEl || !midEl || !modalEl) return;

    hbIdEl.value = active.hbId;
    midEl.value  = machineId;

    // Start time (read-only) shown as local
    const startLocalStr = active.startIso ? isoToLocalInput(active.startIso) : "";
    offStart.value = startLocalStr;

    // End time defaults to "now" local; enforce min/max
    const now = new Date();
    const nowLocalStr = formatForDatetimeLocal(now);
    offEnd.value = nowLocalStr;
    offEnd.min   = startLocalStr || "";
    offEnd.max   = nowLocalStr; // prevent future end times

    // clear invalid state
    setEndInvalid(false);

    // live validation for end input
    offEnd.oninput = function () {
      const start = parseLocalInput(offStart.value);
      const end   = parseLocalInput(offEnd.value);
      const nowDt = new Date();

      if (start && end && end < start) {
        setEndInvalid(true, "End time cannot be before the start time.");
      } else if (end && end > nowDt) {
        setEndInvalid(true, "End time cannot be in the future.");
      } else {
        setEndInvalid(false, "");
      }
    };
    // run once to initialize feedback
    offEnd.dispatchEvent(new Event("input"));

    // show modal
    new bootstrap.Modal(modalEl).show();
  }

  // ---------- radio change handling (No heat break + durations) ----------
  document.querySelectorAll(RADIO_SELECTOR).forEach((radio) => {
    radio.addEventListener("change", function () {
      const machineId = this.dataset.machine;
      const val = this.value;

      // Turn OFF (end heat break) -> open modal
      if (val === "none") {
        const active = ACTIVE.get(machineId);
        if (!active) return; // nothing to end
        openOffModal(machineId, active);
        return;
      }

      // Turn ON with chosen duration
      fetch(`/plant/heat/${machineId}/on/`, {
        method: "POST",
        headers: { "X-CSRFToken": getCsrfToken() },
        body: new URLSearchParams({ duration: val })
      })
      .then(r => r.json())
      .then(data => {
        if (data?.status === "ok") {
          ACTIVE.set(machineId, {
            hbId: String(data.heatbreak_id),
            startIso: data.start_time_iso,
            duration: String(val)
          });
          selectRadio(machineId, val);
        } else {
          selectNone(machineId);
        }
      })
      .catch(() => {
        selectNone(machineId);
      });
    });
  });

  // ---------- modal submit -> validate, POST /off/, clear state ----------
  const offForm = document.getElementById(FORM_ID);
  if (offForm) {
    offForm.addEventListener("submit", function (e) {
      e.preventDefault();

      const hbId = document.getElementById("heatbreakId")?.value;
      const machineId = document.getElementById("offMachineId")?.value;
      const startTimeStr = document.getElementById("offStart")?.value; // local
      const endTimeStr   = document.getElementById("offEnd")?.value;   // local

      const start = parseLocalInput(startTimeStr);
      const end   = parseLocalInput(endTimeStr);
      const nowDt = new Date();

      // Guard: end < start OR end > now -> block
      if ((start && end && end < start) || (end && end > nowDt)) {
        const msg = (start && end && end < start)
          ? "End time cannot be before the start time."
          : "End time cannot be in the future.";
        setEndInvalid(true, msg);
        document.getElementById("offEnd")?.focus();
        return;
      }
      setEndInvalid(false, "");

      fetch(`/plant/heat/${hbId}/off/`, {
        method: "POST",
        headers: { "X-CSRFToken": getCsrfToken() },
        body: new URLSearchParams({ end_time: endTimeStr })
      })
      .then(r => r.json())
      .then(data => {
        if (data?.status === "ok") {
          const modalEl = document.getElementById(MODAL_ID);
          const modal = bootstrap.Modal.getInstance(modalEl);
          if (modal) modal.hide();

          if (machineId) {
            ACTIVE.delete(machineId);
            selectNone(machineId);
          }
        } else {
          // keep the modal open and show invalid (server-side rejection)
          setEndInvalid(true, data?.message || "Could not end heat break.");
        }
      })
      .catch(() => {
        setEndInvalid(true, "Network error. Please try again.");
      });
    });
  }
});
</script>



{% endblock %}
