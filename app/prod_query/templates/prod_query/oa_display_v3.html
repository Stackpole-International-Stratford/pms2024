{% load static %}
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Operational Availability by Line (Monthly View)</title>
        <link href="{% static 'bootstrap/css/bootstrap.min.css' %}" rel="stylesheet">
        <script src="{% static 'bootstrap/js/bootstrap.bundle.min.js' %}"></script>
        <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
        <script src="{% static 'chart.js/chart.umd.js' %}"></script>
        <script src="{% static 'moment.js/moment.min.js' %}"></script>
        <script src="{% static 'chart.js/chartjs-adapter-moment.min.js' %}"></script>
        <script src="{% static 'chart.js/chartjs-plugin-regression.min.js' %}"></script>
    </head>
<body>
    <style>
        .percentage-down {
            cursor: pointer;
        }
        .downtime-minutes {
            cursor: pointer;
        }
        #operation-search {
            max-width: 125px; /* Adjust width */
            font-size: 12px;  /* Adjust font size */
        }
        .original-target {
            cursor: pointer;
        }
    </style>

    <!-- Navbar with Back Button -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="{% url 'prod_query:prod-query_index' %}">
            <button type="button" class="btn btn-outline-primary mx-3">Back</button>
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
    </nav>
    <!-- JE Logo and Title Section -->
    <div class="container mt-4">
        <div class="row bordered mb-3 text-center">
            <div class="col-12">
                <img src="{% static 'images/JE_Logo_PNG.png' %}" alt="JE Logo" style="height: 50px; margin-bottom: 10px;">
                <h1>Operational Availability by Line (Monthly View)</h1>
            </div>
        </div>
    </div>
    <div class="container mt-5">
        <div class="d-flex mb-4 gap-3 align-items-end">
            <!-- Date Picker -->
            <div>
                <label for="date-picker" class="form-label">Select Date:</label>
                <input type="date" id="date-picker" class="form-control">
            </div>

            <!-- Line Selection Dropdown -->
            <div>
                <label for="line-select" class="form-label">Select Line:</label>
                <select id="line-select" class="form-select">
                    <option value="" selected>-- Select a Line --</option>
                </select>
            </div>
        </div>

        <!-- Buttons for Previous and Next Month -->
        <div class="d-flex justify-content-start gap-2 mt-3">
            <button id="previous-month" class="btn btn-secondary">Previous Month</button>
            <button id="next-month" class="btn btn-secondary d-none">Next Month</button>
        </div>

        <style>
            .form-control, .form-select {
                height: calc(2.5rem + 2px); /* Standardize heights */
                display: inline-block; /* Prevent layout shifts */
            }
        </style>

        <!-- OA Results -->
        <div id="oa-results-section" class="card mt-4 d-none">
            <div class="card-body">
                <div id="oa-results" class="alert alert-warning"></div>
            </div>
        </div>

        <!-- Scrap Details Button -->
        <button id="scrap-details" class="btn btn-dark mt-3">Scrap Details</button>
        <button id="export-csv" class="btn btn-warning mt-3">Export as CSV</button>

        <!-- Scrap Details Modal -->
        <div class="modal fade" id="scrapDetailsModal" tabindex="-1" aria-labelledby="scrapDetailsLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="scrapDetailsLabel">Scrap Details</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div id="scrap-details-content">
                            <!-- Content will be dynamically populated -->
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results Table -->
        <div id="results-section" class="mb-4 d-none">
            <h2 id="results-title" class="text-center text-dark mb-4"></h2>
            <div id="results-container"></div>
        </div>

        <!-- Spinner -->
        <div id="loading-spinner" class="text-center d-none">
            <div class="spinner-border text-dark" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p>Loading data, please wait...</p>
        </div>
    </div>

    <!-- Modal for Downtime Details -->
    <div class="modal fade" id="downtimeDetailsModal" tabindex="-1" aria-labelledby="downtimeDetailsLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="downtimeDetailsLabel">Downtime Details</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="downtime-details-content"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Original Target Modal -->
    <div class="modal fade" id="originalTargetModal" tabindex="-1" aria-labelledby="originalTargetModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="originalTargetModalLabel">Update Original Target</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="originalTargetForm">
                        <div class="mb-3">
                            <label for="machine-display" class="form-label">Machine Number:</label>
                            <input type="text" class="form-control" id="machine-display" readonly>
                        </div>
                        <div class="mb-3">
                            <label for="current-original-target" class="form-label">Current Original Target:</label>
                            <input type="number" class="form-control" id="current-original-target" readonly>
                        </div>
                        <div class="mb-3">
                            <label for="effective-date" class="form-label">Effective Date:</label>
                            <input type="date" class="form-control" id="effective-date" readonly>
                        </div>
                        <div class="mb-3">
                            <label for="target-input" class="form-label">New Target:</label>
                            <input type="number" class="form-control" id="target-input" required>
                        </div>
                        <input type="hidden" id="machine-id" value="">
                    </form>
                </div>                
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-warning" id="save-target-btn">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Utility to find all weeks (Sun 11pm to Fri 11pm) in a month
        function getMonthWeeks(dateStr) {
            // Given a selected date within the month, find:
            // 1) The first Sunday 11pm in that month.
            // 2) The last Friday 11pm in that month.
            // Then break the range into multiple weeks: Each week is Sunday 11pm to Friday 11pm.
            const selectedDate = new Date(dateStr + "T00:00:00");
            if (isNaN(selectedDate)) return [];

            const year = selectedDate.getFullYear();
            const month = selectedDate.getMonth();

            // Start of month: find first Sunday at 23:00
            const startOfMonth = new Date(year, month, 1, 23, 0, 0);
            while (startOfMonth.getDay() !== 0) {
                startOfMonth.setDate(startOfMonth.getDate() + 1);
            }

            // End of month: find last Friday at 23:00
            const endOfMonth = new Date(year, month + 1, 0, 23, 0, 0);
            while (endOfMonth.getDay() !== 5) {
                endOfMonth.setDate(endOfMonth.getDate() - 1);
            }

            if (startOfMonth > endOfMonth) {
                // No valid weeks
                return [];
            }

            // Now iterate week by week:
            // Each week start = Sunday 11pm
            // Each week end = that Sunday + 5 days = Friday 11pm
            const weeks = [];
            let currentStart = new Date(startOfMonth);
            while (currentStart <= endOfMonth) {
                const currentEnd = new Date(currentStart);
                currentEnd.setDate(currentEnd.getDate() + 5); // Move to Friday 11pm
                if (currentEnd > endOfMonth) {
                    // Last partial week still considered until the last Friday found
                    break;
                }
                weeks.push({
                    start: currentStart.toISOString(),
                    end: currentEnd.toISOString()
                });

                // Move currentStart by 7 days for next week
                currentStart.setDate(currentStart.getDate() + 7);
            }

            return weeks;
        }
    </script>

    <script>
        $(document).ready(function () {
            // Handle click on original target cells
            $(document).on('click', '.original-target', function () {
                const machineId = $(this).data('machine-id');
                const currentTarget = $(this).text().trim();

                $('#machine-id').val(machineId);
                $('#machine-display').val(machineId);
                $('#current-original-target').val(currentTarget);

                if (window.startDateISO) {
                    const date = new Date(window.startDateISO);
                    const formattedDate = date.getFullYear() +
                        '-' + String(date.getMonth() + 1).padStart(2, '0') +
                        '-' + String(date.getDate()).padStart(2, '0');
                    $('#effective-date').val(formattedDate);
                } else {
                    $('#effective-date').val('');
                }

                $('#target-input').val('');
                $('#originalTargetModal').modal('show');
            });

            $('#save-target-btn').on('click', function () {
                const machineId = $('#machine-id').val();
                const pickedDate = $('#effective-date').val();
                const targetInput = $('#target-input').val();
                const selectedLine = $('#line-select').val();

                if (!pickedDate || !targetInput) {
                    alert('Please fill out all fields!');
                    return;
                }

                // Recalculate effective date: Just use the start of the month range
                const weeks = getMonthWeeks(pickedDate);
                if (!weeks.length) {
                    alert("Invalid effective date range.");
                    return;
                }
                const effectiveDate = weeks[0].start.split('T')[0];

                $.ajax({
                    url: "{% url 'prod_query:update_target' %}",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({
                        machine_id: machineId,
                        effective_date: effectiveDate,
                        target: targetInput,
                        line: selectedLine
                    }),
                    headers: {
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    success: function (response) {
                        if (response.error) {
                            alert(`Error: ${response.error}`);
                        } else {
                            alert('Target updated successfully!');
                            $('#originalTargetModal').modal('hide');
                            $('#line-select, #date-picker').trigger('change');
                        }
                    },
                    error: function (xhr) {
                        console.error("Error response from backend:", xhr);
                        alert('An error occurred while updating the target. Please try again.');
                    }
                });
            });
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const datePicker = document.getElementById('date-picker');
            const nextMonthButton = document.getElementById('next-month');

            const shouldShowNextButton = (selectedDate) => {
                const today = new Date();
                const startOfCurrentMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                startOfCurrentMonth.setHours(0,0,0,0);
                return selectedDate < startOfCurrentMonth;
            };

            const toggleNextMonthButton = () => {
                const selectedDate = new Date(datePicker.value);
                if (isNaN(selectedDate)) {
                    nextMonthButton.classList.add('d-none');
                    return;
                }

                if (shouldShowNextButton(selectedDate)) {
                    nextMonthButton.classList.remove('d-none');
                } else {
                    nextMonthButton.classList.add('d-none');
                }
            };

            toggleNextMonthButton();
            datePicker.addEventListener('change', toggleNextMonthButton);
        });
    </script>

    <script>
        $(document).ready(function () {
            const scrapDetailsButton = $('#scrap-details');
            const exportCsvButton = $('#export-csv');

            scrapDetailsButton.hide();
            exportCsvButton.hide();

            function toggleButtons() {
                const selectedLine = $('#line-select').val();
                if (selectedLine) {
                    scrapDetailsButton.show();
                    exportCsvButton.show();
                } else {
                    scrapDetailsButton.hide();
                    exportCsvButton.hide();
                }
            }

            $('#line-select').on('change', function () {
                toggleButtons();
            });

            toggleButtons();
        });
    </script>

    <script>
        $(document).ready(function () {
            function formatToISO(dateStr) {
                const date = new Date(dateStr);
                if (isNaN(date)) {
                    console.error("Invalid date format:", dateStr);
                    return null;
                }
                return date.toISOString();
            }

            $('#scrap-details').on('click', function () {
                if (!window.scrapAmount || !window.startDateISO) {
                    alert('Please select a line and date to load scrap details.');
                    return;
                }

                $('#scrap-details-content').html('<p>Loading scrap details...</p>');
                $('#scrapDetailsModal').modal('show');

                const scrapLine = $('#line-select').val();
                let startDateISO = window.startDateISO;
                startDateISO = formatToISO(startDateISO);
                if (!startDateISO) {
                    $('#scrap-details-content').html('<p class="text-danger">Invalid start date format. Please try again.</p>');
                    return;
                }

                $.ajax({
                    url: "{% url 'prod_query:total_scrap' %}",
                    type: "GET",
                    data: {
                        scrap_line: scrapLine,
                        start_date: startDateISO
                    },
                    success: function (response) {
                        if (response.error) {
                            console.error("Error in response:", response.error);
                            $('#scrap-details-content').html(`<p class="text-danger">${response.error}</p>`);
                            return;
                        }

                        const scrapData = response.scrap_data || [];
                        if (scrapData.length === 0) {
                            $('#scrap-details-content').html('<p>No scrap details available for the selected line and date.</p>');
                            return;
                        }

                        let tableHtml = `
                            <div class="table-responsive">
                                <table class="table table-bordered table-hover" id="scrap-table">
                                    <thead class="table-light">
                                        <tr>
                                            <th>Scrap Part</th>
                                            <th>
                                                Scrap Operation
                                                <br />
                                                <input type="text" id="operation-search" class="form-control form-control-sm" placeholder="Search by Operation" />
                                            </th>
                                            <th>Scrap Category</th>
                                            <th>Scrap Amount</th>
                                            <th>Scrap Line</th>
                                            <th>Total Cost</th>
                                            <th>Date Current</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                        `;

                        scrapData.forEach(item => {
                            tableHtml += `
                                <tr>
                                    <td>${item['Scrap Part']}</td>
                                    <td class="scrap-operation">${item['Scrap Operation']}</td>
                                    <td>${item['Scrap Category']}</td>
                                    <td>${item['Scrap Amount']}</td>
                                    <td>${item['Scrap Line']}</td>
                                    <td>${item['Total Cost']}</td>
                                    <td>${new Date(item['Date Current']).toLocaleString()}</td>
                                </tr>
                            `;
                        });

                        tableHtml += `
                                    </tbody>
                                </table>
                            </div>
                        `;

                        $('#scrap-details-content').html(tableHtml);

                        $('#operation-search').on('input', function () {
                            const searchTerm = $(this).val().toLowerCase();
                            $('#scrap-table tbody tr').each(function () {
                                const operation = $(this).find('.scrap-operation').text().toLowerCase();
                                if (operation.includes(searchTerm)) {
                                    $(this).show();
                                } else {
                                    $(this).hide();
                                }
                            });
                        });
                    },
                    error: function (xhr, status, error) {
                        console.error("AJAX Request Failed:", status, error, xhr.responseText);
                        $('#scrap-details-content').html('<p class="text-danger">An error occurred while fetching scrap details. Please try again later.</p>');
                    }
                });
            });
        });
    </script>

    <script>
        function highlightTable() {
            const percentageDownCells = document.querySelectorAll('.percentage-down');
            let maxPercentage = -Infinity, minPercentage = Infinity;
            percentageDownCells.forEach(cell => {
                const percentage = parseInt(cell.dataset.percentage, 10);
                if (!isNaN(percentage)) {
                    if (percentage > maxPercentage) maxPercentage = percentage;
                    if (percentage < minPercentage) minPercentage = percentage;
                }
            });

            percentageDownCells.forEach(cell => {
                const percentage = parseInt(cell.dataset.percentage, 10);
                if (percentage === maxPercentage) {
                    cell.style.color = 'red';
                    cell.style.fontWeight = 'bold';
                } else if (percentage === minPercentage) {
                    cell.style.color = 'green';
                    cell.style.fontWeight = 'bold';
                }
            });

            const pCells = document.querySelectorAll('.subtotal-p');
            let minP = Infinity;
            pCells.forEach(cell => {
                const pValue = parseFloat(cell.dataset.p);
                if (!isNaN(pValue) && pValue < minP) {
                    minP = pValue;
                }
            });

            pCells.forEach(cell => {
                const pValue = parseFloat(cell.dataset.p);
                if (pValue === minP) {
                    cell.style.color = 'red';
                    cell.style.fontWeight = 'bold';
                }
            });

            const aCells = document.querySelectorAll('.subtotal-a');
            let minA = Infinity;
            aCells.forEach(cell => {
                const aValue = parseFloat(cell.dataset.a);
                if (!isNaN(aValue) && aValue < minA) {
                    minA = aValue;
                }
            });

            aCells.forEach(cell => {
                const aValue = parseFloat(cell.dataset.a);
                if (aValue === minA) {
                    cell.style.color = 'red';
                    cell.style.fontWeight = 'bold';
                }
            });
        }
    </script>

    <script>
        $(document).on('click', '.percentage-down, .downtime-minutes', function () {
            const percentage = $(this).attr('data-percentage') || null;
            const downtime = $(this).attr('data-downtime') || null;
            const startDateISO = $(this).attr('data-startdateiso');
            const endOfPeriod = $(this).attr('data-endofweek'); 
            const machine = $(this).attr('data-machine');

            if (machine === 'Subtotal' || machine === 'Total') {
                alert('Detailed downtime data is not available for subtotals or totals.');
                return;
            }

            $('#downtime-details-content').html('<p>Loading downtime details...</p>');
            $('#downtimeDetailsModal').modal('show');

            $.ajax({
                url: "{% url 'prod_query:pr_downtime' %}",
                type: "GET",
                data: {
                    assetnum: machine,
                    called4helptime: startDateISO,
                    completedtime: endOfPeriod,
                    csrfmiddlewaretoken: '{{ csrf_token }}'
                },
                success: function (response) {
                    if (response.error) {
                        $('#downtime-details-content').html(`<p class="text-danger">${response.error}</p>`);
                    } else {
                        let contentHTML = `<canvas id="spmChart" style="min-height: 150px; width: 100%;"></canvas>
                            <p><strong>Machine:</strong> ${machine}</p>
                            <p><strong>Start Date:</strong> ${new Date(startDateISO).toLocaleString()}</p>
                            <p><strong>End Date:</strong> ${new Date(endOfPeriod).toLocaleString()}</p>`;

                        if (percentage !== null) {
                            contentHTML += `<p><strong>Downtime Percentage:</strong> ${percentage}%</p>`;
                        } else if (downtime !== null) {
                            contentHTML += `<p><strong>Downtime:</strong> ${downtime} minutes</p>`;
                        }

                        if (response.data && response.data.length > 0) {
                            contentHTML += `<p><strong>Downtime Entries:</strong></p>
                                <div class="table-responsive">
                                    <table class="table table-bordered table-hover">
                                        <thead class="table-light">
                                            <tr>
                                                <th>Problem</th>
                                                <th>Called for Help Time</th>
                                                <th>Completed Time</th>
                                                <th>Downtime (minutes)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                            `;

                            response.data.forEach(entry => {
                                const problem = entry.problem || 'N/A';
                                const calledTime = entry.called4helptime ? new Date(entry.called4helptime).toLocaleString() : 'Unknown';
                                const completedTime = entry.completedtime ? new Date(entry.completedtime).toLocaleString() : 'Still in progress';
                                let downtimeMinutes = 'In Progress';
                                if (entry.called4helptime && entry.completedtime) {
                                    const calledDate = new Date(entry.called4helptime);
                                    const completedDate = new Date(entry.completedtime);
                                    const diffMs = completedDate - calledDate;
                                    const diffMinutes = Math.round(diffMs / 60000);
                                    downtimeMinutes = diffMinutes >= 0 ? diffMinutes : 'Invalid Time';
                                }

                                contentHTML += `
                                    <tr>
                                        <td>${problem}</td>
                                        <td>${calledTime}</td>
                                        <td>${completedTime}</td>
                                        <td>${downtimeMinutes}</td>
                                    </tr>
                                `;
                            });

                            contentHTML += `
                                        </tbody>
                                    </table>
                                </div>
                            `;
                        } else {
                            contentHTML += '<p>No downtime entries found for this period.</p>';
                        }

                        $('#downtime-details-content').html(contentHTML);

                        if (response.chart_data && response.chart_data.labels && response.chart_data.counts) {
                            const ctx = document.getElementById('spmChart');
                            new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: response.chart_data.labels,
                                    datasets: [{
                                        label: 'Strokes Per Minute',
                                        data: response.chart_data.counts,
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: true,
                                    scales: {
                                        y: { beginAtZero: true },
                                        x: { type: 'time' }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        title: { display: true, text: 'Strokes Per Minute' }
                                    }
                                }
                            });
                        }
                    }
                },
                error: function () {
                    $('#downtime-details-content').html('<p class="text-danger">An error occurred while fetching downtime details.</p>');
                }
            });
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('export-csv').addEventListener('click', async () => {
                const table = document.querySelector('#results-container table');
                if (!table) {
                    alert('No data available to export!');
                    return;
                }

                const line = document.getElementById('line-select').value;
                const date = document.getElementById('date-picker').value;
                const filename = `${line}_${date}.csv`;

                function generateCSVContent() {
                    const rows = table.querySelectorAll('tr');
                    const expectedColumns = 10; 

                    let csvContent = '';

                    rows.forEach(row => {
                        const cells = row.querySelectorAll('th, td');
                        let rowData = [];

                        cells.forEach((cell, index) => {
                            const cellText = cell.textContent.trim();
                            if (index === 0 && (cellText.startsWith('Subtotal') || cellText === 'Total')) {
                                rowData.push(`"${cellText}"`);
                                rowData.push(`""`);
                            } else {
                                const escapedText = cellText.replace(/"/g, '""');
                                rowData.push(`"${escapedText}"`);
                            }
                        });

                        const missingCells = expectedColumns - rowData.length;
                        for (let i = 0; i < missingCells; i++) {
                            rowData.push(`""`);
                        }

                        csvContent += rowData.join(',') + '\r\n';
                    });

                    return csvContent;
                }

                const csvData = generateCSVContent();
                const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const formattedDate = `${year}-${month}-${day}`;

            const datePicker = document.getElementById('date-picker');
            datePicker.value = formattedDate;
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const formattedDate = `${year}-${month}-${day}`;

            const datePicker = document.getElementById('date-picker');
            datePicker.value = formattedDate;

            const adjustDateByMonth = (date, months) => {
                const newDate = new Date(date);
                newDate.setMonth(newDate.getMonth() + months);
                return newDate.toISOString().split('T')[0];
            };

            document.getElementById('previous-month').addEventListener('click', () => {
                const currentDate = new Date(datePicker.value);
                datePicker.value = adjustDateByMonth(currentDate, -1);
                datePicker.dispatchEvent(new Event('change'));
            });

            document.getElementById('next-month').addEventListener('click', () => {
                const currentDate = new Date(datePicker.value);
                datePicker.value = adjustDateByMonth(currentDate, 1);
                datePicker.dispatchEvent(new Event('change'));
            });
        });
    </script>

    <script>
        $(document).ready(function () {
            const lines = {{ lines|safe }};
            let ajaxRequestCount = 0;

            function showSpinner() {
                $('#loading-spinner').removeClass('d-none');
            }

            function hideSpinner() {
                $('#loading-spinner').addClass('d-none');
            }

            function incrementAjaxCount() {
                ajaxRequestCount++;
                if (ajaxRequestCount === 1) {
                    showSpinner();
                }
            }

            function decrementAjaxCount() {
                ajaxRequestCount--;
                if (ajaxRequestCount <= 0) {
                    ajaxRequestCount = 0;
                    hideSpinner();
                }
            }

            lines.forEach(line => {
                $('#line-select').append(`<option value="${line.line}">${line.line}</option>`);
            });

            $('#line-select, #date-picker').change(async function () {
                const selectedLine = $('#line-select').val();
                const selectedDate = $('#date-picker').val();

                if (!selectedLine || !selectedDate) {
                    return;
                }

                const selectedDateObj = new Date(selectedDate);
                if (isNaN(selectedDateObj)) {
                    alert('Invalid date selected!');
                    return;
                }

                const lineData = lines.find(line => line.line === selectedLine);
                const scrapLine = lineData.scrap_line;

                const weeks = getMonthWeeks(selectedDate);
                if (!weeks.length) {
                    alert("No valid weekdays range for this month!");
                    return;
                }

                // We will accumulate results from all weeks here:
                let allDowntimeResults = [];
                let allProducedResults = [];
                let allMachineTargets = {};
                let totalScrap = 0;
                let finalStartDate = null;
                let finalEndDate = null;

                // We'll run queries for each week and sum the results
                for (let i = 0; i < weeks.length; i++) {
                    const weekRange = weeks[i];
                    const startDateISO = weekRange.start;
                    const endDateISO = weekRange.end;
                    if (!finalStartDate) finalStartDate = startDateISO;
                    finalEndDate = endDateISO;

                    // AJAX call for downtime/produced
                    incrementAjaxCount();
                    let weekData = null;
                    try {
                        weekData = await $.ajax({
                            url: "{% url 'prod_query:gfx_downtime_and_produced' %}",
                            type: "POST",
                            data: {
                                machines: JSON.stringify(lineData.operations.flatMap(op => op.machines.map(m => m.number))),
                                line: selectedLine,
                                start_date: startDateISO,
                                csrfmiddlewaretoken: '{{ csrf_token }}'
                            }
                        });
                    } catch (err) {
                        console.error('Request failed:', err);
                        alert(`Error fetching data for week starting ${startDateISO}. Check console for details.`);
                        decrementAjaxCount();
                        return;
                    }
                    decrementAjaxCount();

                    if (weekData.error) {
                        console.error('Error:', weekData.error);
                        console.debug('Debug Logs:', weekData.debug);
                        alert(`Error: ${weekData.error}\nDebug Logs: ${JSON.stringify(weekData.debug, null, 2)}`);
                        return;
                    }

                    // AJAX for scrap for this week
                    incrementAjaxCount();
                    let scrapData = null;
                    try {
                        scrapData = await $.ajax({
                            url: "{% url 'prod_query:total_scrap' %}",
                            type: "GET",
                            data: {
                                scrap_line: scrapLine,
                                start_date: startDateISO
                            }
                        });
                    } catch (err) {
                        console.error('Error fetching scrap:', err);
                        decrementAjaxCount();
                        return;
                    }
                    decrementAjaxCount();

                    if (scrapData.error) {
                        alert(scrapData.error);
                        return;
                    }

                    // Accumulate scrap
                    totalScrap += (scrapData.total_scrap_amount || 0);

                    // Accumulate downtime and produced
                    const weekDowntime = weekData.downtime_results || [];
                    const weekProduced = weekData.produced_results || [];
                    const weekTargets = weekData.machine_targets || {};

                    // Merge machine targets (shouldn't conflict, they should be the same for each machine)
                    for (const m in weekTargets) {
                        // We'll just overwrite or keep it. It should not vary by week in a problematic way.
                        allMachineTargets[m] = weekTargets[m];
                    }

                    // Merge downtime results
                    weekDowntime.forEach(r => {
                        const existing = allDowntimeResults.find(x => x.machine === r.machine);
                        if (existing) {
                            existing.downtime += r.downtime;
                        } else {
                            allDowntimeResults.push({ machine: r.machine, downtime: r.downtime });
                        }
                    });

                    // Merge produced results
                    weekProduced.forEach(r => {
                        const existing = allProducedResults.find(x => x.machine === r.machine);
                        if (existing) {
                            existing.produced += r.produced;
                        } else {
                            allProducedResults.push({ machine: r.machine, produced: r.produced });
                        }
                    });
                }

                // After all weeks are processed, we have a cumulative month data:
                window.scrapAmount = totalScrap;
                window.startDateISO = finalStartDate;
                window.endOfWeek = finalEndDate; 

                // Construct a combined data object for displayMachineResults function
                const combinedData = {
                    downtime_results: allDowntimeResults,
                    produced_results: allProducedResults,
                    machine_targets: allMachineTargets,
                    // We'll just pick start_date and end_date as the full month range we processed
                    start_date: new Date(finalStartDate).toLocaleString('en-US', { timeZone: 'America/New_York' }),
                    end_date: new Date(finalEndDate).toLocaleString('en-US', { timeZone: 'America/New_York' })
                };

                displayMachineResults(combinedData, lineData);
            });

            function displayMachineResults(data, lineData) {
                const downtimeResults = data.downtime_results || [];
                const producedResults = data.produced_results || [];
                const adjustedMachineTargets = data.machine_targets || {};

                // Convert start/end from local strings back to date for formatting
                // They were stored as localized strings above, let's just parse them back:
                const startDate = new Date(window.startDateISO);
                const endDate = new Date(window.endOfWeek);
                const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                const formattedStartDate = startDate.toLocaleString(undefined, options);
                const formattedEndDate = endDate.toLocaleString(undefined, options);

                $('#results-title').text(`Results from ${formattedStartDate} to ${formattedEndDate}`);

                // Calculate total potential minutes for the entire month:
                // We summed across multiple weeks. Each week is 7200 potential minutes.
                // Let's count how many entries in downtimeResults. Wait, we must know how many weeks:
                // Actually, we know we processed multiple weeks. The best approach is to determine how many weeks from startDate and endDate:
                // Every full week is Sunday 11pm to Friday 11pm = 7200 minutes per machine per week.
                // Let's calculate weeks count by difference in multiples of 7 days:
                // We had them from getMonthWeeks. Let's just recalculate quickly:
                let totalWeeks = 0;
                {
                    let temp = new Date(startDate);
                    while (temp <= endDate) {
                        totalWeeks++;
                        temp.setDate(temp.getDate() + 7);
                    }
                }

                // If the month isn't fully completed, we scale by elapsed time:
                let totalPotentialMinutesPerMachine = totalWeeks * 7200;
                const now = new Date();
                if (now >= startDate && now <= endDate) {
                    const elapsedTime = now - startDate;
                    const totalMonthTime = endDate - startDate;
                    const elapsedPercentage = elapsedTime / totalMonthTime;
                    totalPotentialMinutesPerMachine = 7200 * totalWeeks * elapsedPercentage;
                }

                const machineToOp = {};
                lineData.operations.forEach(opData => {
                    const op = opData.op;
                    opData.machines.forEach(machine => {
                        machineToOp[machine.number] = op;
                    });
                });

                const opGroups = {};
                lineData.operations.forEach(opData => {
                    const op = opData.op;
                    opGroups[op] = {
                        machines: [],
                        subtotal: {
                            downtime: 0,
                            produced: 0,
                            target: 0,
                            adjustedTarget: 0,
                            potentialMinutes: 0
                        }
                    };
                });

                const totals = {
                    totalDowntime: 0,
                    totalProduced: 0,
                    totalTarget: 0,
                    totalAdjustedTarget: 0,
                    totalPotentialMinutes: 0
                };

                downtimeResults.forEach((result) => {
                    const machine = result.machine;
                    let downtime = parseFloat(result.downtime) || 0;
                    // Now we have total downtime summed over the month. No need to min it by totalPotential once again.
                    if (downtime > totalPotentialMinutesPerMachine) {
                        // It's possible downtime sums exceed totalPotential. We'll just keep them as is. 
                        // (If needed, clamp: downtime = Math.min(downtime, totalPotentialMinutesPerMachine);)
                        downtime = Math.min(downtime, totalPotentialMinutesPerMachine);
                    }
                    downtime = Math.round(downtime);

                    const produced = parseFloat((producedResults.find(p => p.machine === machine) || {}).produced) || 0;
                    const targetInfo = adjustedMachineTargets[machine] || {};
                    const originalTarget = targetInfo.original_target || 0;

                    // Scale the target for the entire month by the factor of (totalPotential / (7200 * weeks))
                    const scaling_factor = totalPotentialMinutesPerMachine / (7200 * totalWeeks);
                    const adjustedOriginalTarget = originalTarget * totalWeeks * scaling_factor; 

                    const percentageDown = totalPotentialMinutesPerMachine > 0
                        ? Math.round((downtime / totalPotentialMinutesPerMachine) * 100)
                        : 0;
                    const adjustedTarget = Math.max(
                        0,
                        adjustedOriginalTarget * (1 - (downtime / totalPotentialMinutesPerMachine))
                    );
                    const P = (adjustedTarget === 0 && produced === 0) ? 1 :
                        (adjustedTarget > 0 ? (produced / adjustedTarget) : 0);
                    const A = totalPotentialMinutesPerMachine > 0
                        ? Math.max(0, (totalPotentialMinutesPerMachine - downtime) / totalPotentialMinutesPerMachine)
                        : 0;

                    totals.totalDowntime += downtime;
                    totals.totalProduced += produced;
                    totals.totalTarget += adjustedOriginalTarget;
                    totals.totalAdjustedTarget += adjustedTarget;
                    totals.totalPotentialMinutes += totalPotentialMinutesPerMachine;

                    const op = machineToOp[machine] || 'Unknown';

                    opGroups[op].machines.push({
                        machine: machine,
                        downtime: downtime,
                        produced: produced,
                        target: adjustedOriginalTarget,
                        adjustedTarget: adjustedTarget,
                        potentialMinutes: totalPotentialMinutesPerMachine,
                        P: P,
                        A: A,
                        percentageDown: percentageDown
                    });

                    opGroups[op].subtotal.downtime += downtime;
                    opGroups[op].subtotal.produced += produced;
                    opGroups[op].subtotal.target += adjustedOriginalTarget;
                    opGroups[op].subtotal.adjustedTarget += adjustedTarget;
                    opGroups[op].subtotal.potentialMinutes += totalPotentialMinutesPerMachine;
                });

                const overallP = totals.totalAdjustedTarget > 0 ? (totals.totalProduced / totals.totalAdjustedTarget) : 0;
                const overallA = totals.totalPotentialMinutes > 0
                    ? ((totals.totalPotentialMinutes - totals.totalDowntime) / totals.totalPotentialMinutes)
                    : 0;

                let tableHtml = `
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Op</th>
                            <th>Machine</th>
                            <th>Total Produced</th>
                            <th>Original Target</th>
                            <th>Adjusted Target</th>
                            <th>Downtime (minutes)</th>
                            <th>Total Potential Minutes</th>
                            <th>Percentage Down</th>
                            <th>P</th>
                            <th>A</th>
                        </tr>
                    </thead>
                    <tbody>
                `;

                for (const op of Object.keys(opGroups)) {
                    const opData = opGroups[op];
                    tableHtml += `
                        <tr>
                            <td colspan="10" class="table-secondary"><strong>Op ${op}</strong></td>
                        </tr>
                    `;

                    opData.machines.forEach(machineData => {
                        tableHtml += `
                            <tr>
                                <td></td>
                                <td>${machineData.machine}</td>
                                <td>${machineData.produced}</td>
                                <td class="original-target"
                                    data-machine-id="${machineData.machine}"
                                    data-bs-toggle="tooltip"
                                    title="Click to update original target">
                                    ${machineData.target.toFixed(0)}
                                </td>
                                <td>${machineData.adjustedTarget.toFixed(0)}</td>
                                <td class="downtime-minutes"
                                    data-downtime="${machineData.downtime}"
                                    data-startdateiso="${window.startDateISO}"
                                    data-endofweek="${window.endOfWeek}"
                                    data-machine="${machineData.machine}"
                                    data-bs-toggle="tooltip"
                                    title="Click to view details">
                                    ${machineData.downtime}
                                </td>
                                <td>${machineData.potentialMinutes.toFixed(0)}</td>
                                <td class="percentage-down"
                                    data-percentage="${machineData.percentageDown}"
                                    data-startdateiso="${window.startDateISO}"
                                    data-endofweek="${window.endOfWeek}"
                                    data-machine="${machineData.machine}"
                                    data-bs-toggle="tooltip"
                                    title="Click to view details">
                                    ${machineData.percentageDown}%
                                </td>
                                <td>${(machineData.P * 100).toFixed(2)}%</td>
                                <td>${(machineData.A * 100).toFixed(2)}%</td>
                            </tr>
                        `;
                    });

                    const subtotalP = opData.subtotal.adjustedTarget > 0
                        ? opData.subtotal.produced / opData.subtotal.adjustedTarget
                        : (opData.subtotal.produced === 0 ? 1 : 0);
                    const subtotalA = opData.subtotal.potentialMinutes > 0
                        ? ((opData.subtotal.potentialMinutes - opData.subtotal.downtime) / opData.subtotal.potentialMinutes)
                        : 0;
                    const percentageDown = opData.subtotal.potentialMinutes > 0
                        ? Math.round((opData.subtotal.downtime / opData.subtotal.potentialMinutes) * 100)
                        : 0;

                    tableHtml += `
                        <tr class="table-warning">
                            <td colspan="2"><strong>Subtotal for Op ${op}</strong></td>
                            <td><strong>${opData.subtotal.produced}</strong></td>
                            <td><strong>${opData.subtotal.target.toFixed(0)}</strong></td>
                            <td><strong>${opData.subtotal.adjustedTarget.toFixed(0)}</strong></td>
                            <td class="downtime-minutes"
                                data-downtime="${opData.subtotal.downtime}"
                                data-startdateiso="${window.startDateISO}"
                                data-endofweek="${window.endOfWeek}"
                                data-machine="Subtotal"
                                data-bs-toggle="tooltip"
                                title="Click to view details">
                                <strong>${opData.subtotal.downtime}</strong>
                            </td>
                            <td><strong>${opData.subtotal.potentialMinutes.toFixed(0)}</strong></td>
                            <td class="percentage-down"
                                data-percentage="${percentageDown}"
                                data-startdateiso="${window.startDateISO}"
                                data-endofweek="${window.endOfWeek}"
                                data-machine="Subtotal"
                                data-bs-toggle="tooltip"
                                title="Click to view details">
                                <strong>${percentageDown}%</strong>
                            </td>
                            <td class="subtotal-p" data-p="${subtotalP}"><strong>${(subtotalP * 100).toFixed(2)}%</strong></td>
                            <td class="subtotal-a" data-a="${subtotalA}"><strong>${(subtotalA * 100).toFixed(2)}%</strong></td>
                        </tr>
                    `;
                }

                const totalPercentageDown = totals.totalPotentialMinutes > 0
                    ? Math.round((totals.totalDowntime / totals.totalPotentialMinutes) * 100)
                    : 0;

                tableHtml += `
                </tbody>
                <tfoot>
                    <tr class="table-success">
                        <th colspan="2">Total</th>
                        <th>${totals.totalProduced}</th>
                        <th>${totals.totalTarget.toFixed(0)}</th>
                        <th>${totals.totalAdjustedTarget.toFixed(0)}</th>
                        <td class="downtime-minutes"
                            data-downtime="${totals.totalDowntime}"
                            data-startdateiso="${window.startDateISO}"
                            data-endofweek="${window.endOfWeek}"
                            data-machine="Total"
                            data-bs-toggle="tooltip"
                            title="Click to view details">
                            ${totals.totalDowntime}
                        </td>
                        <th>${totals.totalPotentialMinutes.toFixed(0)}</th>
                        <th class="percentage-down"
                            data-percentage="${totalPercentageDown}"
                            data-startdateiso="${window.startDateISO}"
                            data-endofweek="${window.endOfWeek}"
                            data-machine="Total"
                            data-bs-toggle="tooltip"
                            title="Click to view details">
                            ${totalPercentageDown}%
                        </th>
                        <th>${(overallP * 100).toFixed(2)}%</th>
                        <th>${(overallA * 100).toFixed(2)}%</th>
                    </tr>
                </tfoot>
                </table>`;

                $('#results-section').removeClass('d-none');
                $('#results-container').html(tableHtml);

                calculateOverallOA(overallP, overallA, totals.totalProduced);
                highlightTable();
            }

            function calculateOverallOA(overallP, overallA, totalProduced) {
                const scrapAmount = window.scrapAmount || 0;
                const lastOpSubtotalProduced = (() => {
                    const resultsTable = $('#results-container table tbody');
                    const lastOpRow = resultsTable.find('tr.table-warning:last');
                    const producedCell = lastOpRow.find('td:nth-child(2)');
                    return parseInt(producedCell.text().trim()) || 0;
                })();

                const Q = lastOpSubtotalProduced > 0 
                    ? ((lastOpSubtotalProduced / (lastOpSubtotalProduced + scrapAmount)) * 100).toFixed(2)
                    : "0.00";

                const OA = (overallP * overallA * (Q / 100) * 100).toFixed(2);
                const overallPPercent = (overallP * 100).toFixed(2);
                const overallAPercent = (overallA * 100).toFixed(2);

                $('#oa-results-section').removeClass('d-none');
                $('#oa-results').html(`
                    <p><strong>Operational Availability:</strong> ${OA}% (P=${overallPPercent}%, A=${overallAPercent}%, Q=${Q}%)</p>
                `);
            }
        });
    </script>
</body>
</html>
