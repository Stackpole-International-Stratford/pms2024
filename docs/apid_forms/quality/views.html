<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>quality.views API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quality.views</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="quality.views.add_feat"><code class="name flex">
<span>def <span class="ident">add_feat</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def add_feat(request):
    &#34;&#34;&#34;
    Add a new Feat entry for a specified Part via JSON payload.

    Expects a POST request with a JSON body containing:
      - part_number (str):   The Part’s identifier (HTML-encoded ampersands allowed).
      - name (str):          The name of the new Feat.
      - alarm (any):         The alarm threshold or descriptor for the Feat.
      - critical (bool):     Optional; whether the Feat is critical (defaults to False).

    Workflow:
      1. Parse the JSON payload.
      2. Validate that `part_number` and `name` are provided; return HTTP 400 if missing.
      3. Lookup the Part by `part_number`; return HTTP 404 if not found.
      4. Compute the next display order as (existing feat count + 1).
      5. Create the new Feat with the given fields and computed order.
      6. Return JSON `{&#34;status&#34;: &#34;success&#34;, &#34;feat_id&#34;: &lt;new id&gt;, &#34;new_order&#34;: &lt;order&gt;}`.

    Error Handling:
      - JSON decoding errors: HTTP 400 with `{&#34;status&#34;:&#34;error&#34;,&#34;message&#34;:&#34;Invalid JSON data.&#34;}`.
      - Missing required fields: HTTP 400 with `{&#34;status&#34;:&#34;error&#34;,&#34;message&#34;:&#34;Missing required fields.&#34;}`.
      - Part not found: HTTP 404 with `{&#34;status&#34;:&#34;error&#34;,&#34;message&#34;:&#34;Part not found.&#34;}`.
      - Other exceptions: HTTP 500 with `{&#34;status&#34;:&#34;error&#34;,&#34;message&#34;:&lt;error&gt;}`.
      - Non-POST requests: HTTP 400 with `{&#34;status&#34;:&#34;error&#34;,&#34;message&#34;:&#34;Invalid request method.&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be POST with a JSON body.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success or error with appropriate HTTP status.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        try:
            data = json.loads(request.body)

            part_number = data.get(&#39;part_number&#39;, &#39;&#39;).replace(&#34;&amp;amp;&#34;, &#34;&amp;&#34;)
            name = data.get(&#39;name&#39;)
            alarm = data.get(&#39;alarm&#39;)
            critical = data.get(&#39;critical&#39;, False)

            if not part_number or not name:
                print(f&#34;ERROR: Missing required fields - part_number: &#39;{part_number}&#39;, name: &#39;{name}&#39;&#34;)
                return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Missing required fields.&#39;}, status=400)

            # Retrieve part from the database
            try:
                part = Part.objects.get(part_number=part_number)
            except Part.DoesNotExist:
                print(f&#34;ERROR: Part with part_number &#39;{part_number}&#39; not found.&#34;)
                return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Part not found.&#39;}, status=404)

            # Create the new Feat entry
            new_order = part.feat_set.count() + 1
            feat = Feat.objects.create(
                part=part,
                name=name,
                order=new_order,
                alarm=alarm,
                critical=critical
            )

            return JsonResponse({&#39;status&#39;: &#39;success&#39;, &#39;feat_id&#39;: feat.id, &#39;new_order&#39;: new_order})

        except json.JSONDecodeError as e:
            print(f&#34;ERROR: JSON decoding failed - {e}&#34;)
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Invalid JSON data.&#39;}, status=400)

        except Exception as e:
            print(f&#34;ERROR: Unexpected exception - {e}&#34;)
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: str(e)}, status=500)

    return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Invalid request method.&#39;}, status=400)</code></pre>
</details>
<div class="desc"><p>Add a new Feat entry for a specified Part via JSON payload.</p>
<p>Expects a POST request with a JSON body containing:
- part_number (str):
The Part’s identifier (HTML-encoded ampersands allowed).
- name (str):
The name of the new Feat.
- alarm (any):
The alarm threshold or descriptor for the Feat.
- critical (bool):
Optional; whether the Feat is critical (defaults to False).</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse the JSON payload.</li>
<li>Validate that <code>part_number</code> and <code>name</code> are provided; return HTTP 400 if missing.</li>
<li>Lookup the Part by <code>part_number</code>; return HTTP 404 if not found.</li>
<li>Compute the next display order as (existing feat count + 1).</li>
<li>Create the new Feat with the given fields and computed order.</li>
<li>Return JSON <code>{"status": "success", "feat_id": &lt;new id&gt;, "new_order": &lt;order&gt;}</code>.</li>
</ol>
<p>Error Handling:
- JSON decoding errors: HTTP 400 with <code>{"status":"error","message":"Invalid JSON data."}</code>.
- Missing required fields: HTTP 400 with <code>{"status":"error","message":"Missing required fields."}</code>.
- Part not found: HTTP 404 with <code>{"status":"error","message":"Part not found."}</code>.
- Other exceptions: HTTP 500 with <code>{"status":"error","message":&lt;error&gt;}</code>.
- Non-POST requests: HTTP 400 with <code>{"status":"error","message":"Invalid request method."}</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be POST with a JSON body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success or error with appropriate HTTP status.</dd>
</dl></div>
</dd>
<dt id="quality.views.add_new_entry_with_asset"><code class="name flex">
<span>def <span class="ident">add_new_entry_with_asset</span></span>(<span>epv_id, new_asset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_new_entry_with_asset(epv_id, new_asset):
    &#34;&#34;&#34;
    Duplicate an existing EPV asset record with a new Asset value.

    Connects to the database via `get_creds()`, retrieves the row from
    `quality_epv_assets` identified by `epv_id`, and inserts a new record
    copying all fields except `Asset`, which is set to `new_asset` (with
    “.0” appended). Returns the newly inserted row as a dict with trailing
    “.0” stripped from its `Asset` value.

    Parameters
    ----------
    epv_id : int
        The primary key of the existing `quality_epv_assets` record to duplicate.
    new_asset : str
        The new Asset value (without “.0”); “.0” will be appended internally.

    Returns
    -------
    dict or None
        A dictionary representing the newly inserted row, with keys:
        `id, QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset`.
        The returned `Asset` string will have any trailing “.0” removed.
        Returns `None` if the original row is not found or on database error.

    Notes
    -----
    - Uses `add_zeros()` to append “.0” to the provided `new_asset` string.
    - Commits the insert before fetching and returning the new record.
    - Errors are logged via `print()`; no exceptions are propagated.
    &#34;&#34;&#34;
    try:
        connection = get_creds()
        if connection.is_connected():
            cursor = connection.cursor(dictionary=True)

            # Retrieve the original row&#39;s data
            cursor.execute(&#34;&#34;&#34;
                SELECT QC1, OP1, Check1, Desc1, Method1, Interval1, Person 
                FROM quality_epv_assets 
                WHERE id = %s
            &#34;&#34;&#34;, (epv_id,))
            original_row = cursor.fetchone()

            if not original_row:
                print(f&#34;No entry found for ID: {epv_id}&#34;)
                return None

            # Ensure the new asset value has &#34;.0&#34; appended
            new_asset = add_zeros(new_asset)

            # Insert a new row with the copied data and the new asset
            insert_query = &#34;&#34;&#34;
                INSERT INTO quality_epv_assets (QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            &#34;&#34;&#34;
            cursor.execute(insert_query, (
                original_row[&#34;QC1&#34;], original_row[&#34;OP1&#34;], original_row[&#34;Check1&#34;],
                original_row[&#34;Desc1&#34;], original_row[&#34;Method1&#34;], original_row[&#34;Interval1&#34;],
                original_row[&#34;Person&#34;], new_asset
            ))
            connection.commit()

            new_entry_id = cursor.lastrowid  # Get the ID of the inserted row
            print(f&#34;New entry added with ID: {new_entry_id}&#34;)

            # Fetch the newly inserted row
            cursor.execute(&#34;&#34;&#34;
                SELECT id, QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset 
                FROM quality_epv_assets 
                WHERE id = %s
            &#34;&#34;&#34;, (new_entry_id,))
            new_entry = cursor.fetchone()

            # Remove trailing &#34;.0&#34; before sending data to frontend
            if new_entry:
                new_entry[&#34;Asset&#34;] = remove_zeros(new_entry[&#34;Asset&#34;])

            return new_entry

    except Error as e:
        print(f&#34;Database error: {e}&#34;)
        return None
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()</code></pre>
</details>
<div class="desc"><p>Duplicate an existing EPV asset record with a new Asset value.</p>
<p>Connects to the database via <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code>, retrieves the row from
<code>quality_epv_assets</code> identified by <code>epv_id</code>, and inserts a new record
copying all fields except <code>Asset</code>, which is set to <code>new_asset</code> (with
“.0” appended). Returns the newly inserted row as a dict with trailing
“.0” stripped from its <code>Asset</code> value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>epv_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the existing <code>quality_epv_assets</code> record to duplicate.</dd>
<dt><strong><code>new_asset</code></strong> :&ensp;<code>str</code></dt>
<dd>The new Asset value (without “.0”); “.0” will be appended internally.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> or <code>None</code></dt>
<dd>A dictionary representing the newly inserted row, with keys:
<code>id, QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset</code>.
The returned <code>Asset</code> string will have any trailing “.0” removed.
Returns <code>None</code> if the original row is not found or on database error.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Uses <code><a title="quality.views.add_zeros" href="#quality.views.add_zeros">add_zeros()</a></code> to append “.0” to the provided <code>new_asset</code> string.</li>
<li>Commits the insert before fetching and returning the new record.</li>
<li>Errors are logged via <code>print()</code>; no exceptions are propagated.</li>
</ul></div>
</dd>
<dt id="quality.views.add_new_epv"><code class="name flex">
<span>def <span class="ident">add_new_epv</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def add_new_epv(request):
    &#34;&#34;&#34;
    Create a new EPV asset record from a JSON payload.

    This view only accepts POST requests with a JSON body containing the fields:
      - qc1 (str|int):       QC1 grouping value.
      - op1 (str):           First operation identifier.
      - check1 (str):        First check description.
      - desc1 (str):         First description text.
      - method1 (str):       First method specification.
      - interval1 (str|int): Interval for the check.
      - person (str):        Responsible person’s name.
      - asset (str|int):     Asset identifier (will be zero-padded).

    Workflow:
      1. Parse and validate the JSON payload.
      2. Zero-pad the `asset` value via `add_zeros()`.
      3. Connect to the database and insert a new row into `quality_epv_assets`.
      4. Commit the transaction and fetch the newly inserted row.
      5. Remove any trailing “.0” from the Asset value via `remove_zeros()`.
      6. Return a JSON response with:
         - `message`: Success confirmation.
         - `new_entry`: Dict of the inserted record.
         - HTTP status 201.

    Error Handling:
      - If the request method is not POST, returns HTTP 405 with an error.
      - If the JSON body is invalid, returns HTTP 400 with `{&#34;error&#34;: &#34;Invalid JSON&#34;}`.
      - If a database error occurs, returns HTTP 500 with `{&#34;error&#34;: &#34;Database error: &lt;msg&gt;&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request containing the JSON payload.

    Returns
    -------
    django.http.JsonResponse
        - On success: `{&#34;message&#34;: &#34;New entry added successfully!&#34;, &#34;new_entry&#34;: {...}}`, status=201.
        - On error: `{&#34;error&#34;: &lt;message&gt;}`, status=400, 405, or 500.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        try:
            data = json.loads(request.body)

            # Ensure asset is properly formatted
            if &#34;asset&#34; in data:
                data[&#34;asset&#34;] = add_zeros(str(data[&#34;asset&#34;]))  # Convert asset to string before processing

            connection = get_creds()
            if connection.is_connected():
                cursor = connection.cursor(dictionary=True)

                # Insert the new EPV entry into the database
                insert_query = &#34;&#34;&#34;
                    INSERT INTO quality_epv_assets (QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                &#34;&#34;&#34;
                cursor.execute(insert_query, (
                    data[&#34;qc1&#34;], data[&#34;op1&#34;], data[&#34;check1&#34;], data[&#34;desc1&#34;], 
                    data[&#34;method1&#34;], data[&#34;interval1&#34;], data[&#34;person&#34;], data[&#34;asset&#34;]
                ))
                connection.commit()

                new_entry_id = cursor.lastrowid  # Get the newly inserted row ID

                # Fetch the newly inserted row
                cursor.execute(&#34;&#34;&#34;
                    SELECT id, QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset 
                    FROM quality_epv_assets 
                    WHERE id = %s
                &#34;&#34;&#34;, (new_entry_id,))
                new_entry = cursor.fetchone()

                # Remove trailing &#34;.0&#34; before sending data to frontend
                if new_entry:
                    new_entry[&#34;Asset&#34;] = remove_zeros(new_entry[&#34;Asset&#34;])

                cursor.close()
                connection.close()

                return JsonResponse({&#34;message&#34;: &#34;New entry added successfully!&#34;, &#34;new_entry&#34;: new_entry}, status=201)

        except Error as e:
            return JsonResponse({&#34;error&#34;: f&#34;Database error: {e}&#34;}, status=500)
        except json.JSONDecodeError:
            return JsonResponse({&#34;error&#34;: &#34;Invalid JSON&#34;}, status=400)

    return JsonResponse({&#34;error&#34;: &#34;Invalid request method&#34;}, status=405)</code></pre>
</details>
<div class="desc"><p>Create a new EPV asset record from a JSON payload.</p>
<p>This view only accepts POST requests with a JSON body containing the fields:
- qc1 (str|int):
QC1 grouping value.
- op1 (str):
First operation identifier.
- check1 (str):
First check description.
- desc1 (str):
First description text.
- method1 (str):
First method specification.
- interval1 (str|int): Interval for the check.
- person (str):
Responsible person’s name.
- asset (str|int):
Asset identifier (will be zero-padded).</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse and validate the JSON payload.</li>
<li>Zero-pad the <code>asset</code> value via <code><a title="quality.views.add_zeros" href="#quality.views.add_zeros">add_zeros()</a></code>.</li>
<li>Connect to the database and insert a new row into <code>quality_epv_assets</code>.</li>
<li>Commit the transaction and fetch the newly inserted row.</li>
<li>Remove any trailing “.0” from the Asset value via <code><a title="quality.views.remove_zeros" href="#quality.views.remove_zeros">remove_zeros()</a></code>.</li>
<li>Return a JSON response with:</li>
<li><code>message</code>: Success confirmation.</li>
<li><code>new_entry</code>: Dict of the inserted record.</li>
<li>HTTP status 201.</li>
</ol>
<p>Error Handling:
- If the request method is not POST, returns HTTP 405 with an error.
- If the JSON body is invalid, returns HTTP 400 with <code>{"error": "Invalid JSON"}</code>.
- If a database error occurs, returns HTTP 500 with <code>{"error": "Database error: &lt;msg&gt;"}</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request containing the JSON payload.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>
<ul>
<li>On success: <code>{"message": "New entry added successfully!", "new_entry": {...}}</code>, status=201.</li>
<li>On error: <code>{"error": &lt;message&gt;}</code>, status=400, 405, or 500.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.add_zeros"><code class="name flex">
<span>def <span class="ident">add_zeros</span></span>(<span>asset_value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_zeros(asset_value):
    &#34;&#34;&#34;
    Ensures that asset values always end with &#34;.0&#34;.
    &#34;&#34;&#34;
    if isinstance(asset_value, str) and not asset_value.endswith(&#34;.0&#34;):
        return asset_value + &#34;.0&#34;
    return asset_value</code></pre>
</details>
<div class="desc"><p>Ensures that asset values always end with ".0".</p></div>
</dd>
<dt id="quality.views.change_part"><code class="name flex">
<span>def <span class="ident">change_part</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_part(request):
    &#34;&#34;&#34;
    Render a part‐selection page or redirect to the part‐clock PDF form.

    - GET:
        • Retrieve all Part instances.
        • Render &#39;quality/change_part.html&#39; with context:
            - `parts`: QuerySet of all Part objects.

    - POST:
        • Read `selected_part` from form data.
        • If a part is selected, redirect to the `pdf_part_clock_form` view
          (URL: &#39;/quality/pdf/part_clock/?part_number=&lt;selected_part&gt;&#39;).
        • If no part is selected, log a warning and re-render the selection page.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, which may be GET or POST with form data.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or invalid POST: renders &#39;quality/change_part.html&#39; with `parts`.
        - On valid POST with `selected_part`: redirects to the part‐clock form.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:

        # Capture the selected part from the form
        selected_part = request.POST.get(&#39;selected_part&#39;)



        if selected_part:
            return redirect(f&#39;/quality/pdf/part_clock/?part_number={selected_part}&#39;)
        else:
            print(&#34;No part was selected.&#34;)
    else:

        # If it&#39;s a GET request, just render the part selection page
        parts = Part.objects.all()
    return render(request, &#39;quality/change_part.html&#39;, {&#39;parts&#39;: parts})</code></pre>
</details>
<div class="desc"><p>Render a part‐selection page or redirect to the part‐clock PDF form.</p>
<ul>
<li>
<p>GET:
• Retrieve all Part instances.
• Render 'quality/change_part.html' with context:
- <code>parts</code>: QuerySet of all Part objects.</p>
</li>
<li>
<p>POST:
• Read <code>selected_part</code> from form data.
• If a part is selected, redirect to the <code><a title="quality.views.pdf_part_clock_form" href="#quality.views.pdf_part_clock_form">pdf_part_clock_form()</a></code> view
(URL: '/quality/pdf/part_clock/?part_number=<selected_part>').
• If no part is selected, log a warning and re-render the selection page.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, which may be GET or POST with form data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or invalid POST: renders 'quality/change_part.html' with <code>parts</code>.</li>
<li>On valid POST with <code>selected_part</code>: redirects to the part‐clock form.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.delete_epv"><code class="name flex">
<span>def <span class="ident">delete_epv</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def delete_epv(request):
    &#34;&#34;&#34;
    Delete an EPV asset record by ID via a JSON POST request.

    Expects a POST request with a JSON body containing:
      - id (int): The primary key of the `quality_epv_assets` record to delete.

    Workflow:
      1. Parse and validate the JSON payload; return HTTP 400 if missing or invalid.
      2. Establish a MySQL connection via `get_creds()`; return HTTP 500 on connection error.
      3. Execute a DELETE statement on `quality_epv_assets` for the given `id`.
      4. Commit the transaction and close the connection.
      5. Return HTTP 200 with `{&#34;message&#34;: &#34;EPV deleted successfully&#34;}` on success.

    Error Handling:
      - Missing `id` in payload: HTTP 400 with `{&#34;error&#34;: &#34;Missing ID&#34;}`.
      - JSON decode error: HTTP 400 with `{&#34;error&#34;: &#34;Invalid JSON&#34;}`.
      - Database errors: HTTP 500 with `{&#34;error&#34;: &#34;Database error: &lt;details&gt;&#34;}`.
      - Non-POST requests: HTTP 405 with `{&#34;error&#34;: &#34;Invalid request method&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be a POST with JSON body.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success or the type of error, with appropriate HTTP status.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        try:
            data = json.loads(request.body)
            epv_id = data.get(&#34;id&#34;)

            if not epv_id:
                return JsonResponse({&#34;error&#34;: &#34;Missing ID&#34;}, status=400)

            connection = get_creds()
            if connection.is_connected():
                cursor = connection.cursor()
                delete_query = &#34;DELETE FROM quality_epv_assets WHERE id = %s&#34;
                cursor.execute(delete_query, (epv_id,))
                connection.commit()
                cursor.close()
                connection.close()
                return JsonResponse({&#34;message&#34;: &#34;EPV deleted successfully&#34;}, status=200)

        except Error as e:
            return JsonResponse({&#34;error&#34;: f&#34;Database error: {e}&#34;}, status=500)
        except json.JSONDecodeError:
            return JsonResponse({&#34;error&#34;: &#34;Invalid JSON&#34;}, status=400)

    return JsonResponse({&#34;error&#34;: &#34;Invalid request method&#34;}, status=405)</code></pre>
</details>
<div class="desc"><p>Delete an EPV asset record by ID via a JSON POST request.</p>
<p>Expects a POST request with a JSON body containing:
- id (int): The primary key of the <code>quality_epv_assets</code> record to delete.</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse and validate the JSON payload; return HTTP 400 if missing or invalid.</li>
<li>Establish a MySQL connection via <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code>; return HTTP 500 on connection error.</li>
<li>Execute a DELETE statement on <code>quality_epv_assets</code> for the given <code>id</code>.</li>
<li>Commit the transaction and close the connection.</li>
<li>Return HTTP 200 with <code>{"message": "EPV deleted successfully"}</code> on success.</li>
</ol>
<p>Error Handling:
- Missing <code>id</code> in payload: HTTP 400 with <code>{"error": "Missing ID"}</code>.
- JSON decode error: HTTP 400 with <code>{"error": "Invalid JSON"}</code>.
- Database errors: HTTP 500 with <code>{"error": "Database error: &lt;details&gt;"}</code>.
- Non-POST requests: HTTP 405 with <code>{"error": "Invalid request method"}</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be a POST with JSON body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success or the type of error, with appropriate HTTP status.</dd>
</dl></div>
</dd>
<dt id="quality.views.delete_feat"><code class="name flex">
<span>def <span class="ident">delete_feat</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def delete_feat(request):
    &#34;&#34;&#34;
    Delete a Feat record based on JSON input.

    Expects a POST request with a JSON body containing:
      - id (int): The primary key of the Feat to delete.

    Workflow:
      1. Parse the JSON payload and extract `id`.
      2. Retrieve the Feat instance by primary key.
      3. Delete the Feat.
      4. Return a JSON response indicating success.

    Error Handling:
      - If the Feat does not exist, returns `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Feat not found.&#34;}`.
      - On other exceptions, returns `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &lt;error message&gt;}`.
      - Non-POST requests return HTTP 400 with `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Invalid request method.&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be POST with a JSON body.

    Returns
    -------
    django.http.JsonResponse
        - On success: `{&#34;status&#34;: &#34;success&#34;}` (HTTP 200).
        - On error:   `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &lt;details&gt;}`.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        data = json.loads(request.body)
        feat_id = data.get(&#39;id&#39;)

        try:
            feat = Feat.objects.get(id=feat_id)
            feat.delete()

            return JsonResponse({&#39;status&#39;: &#39;success&#39;})
        except Feat.DoesNotExist:
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Feat not found.&#39;})
        except Exception as e:
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: str(e)})

    return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Invalid request method.&#39;}, status=400)</code></pre>
</details>
<div class="desc"><p>Delete a Feat record based on JSON input.</p>
<p>Expects a POST request with a JSON body containing:
- id (int): The primary key of the Feat to delete.</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse the JSON payload and extract <code>id</code>.</li>
<li>Retrieve the Feat instance by primary key.</li>
<li>Delete the Feat.</li>
<li>Return a JSON response indicating success.</li>
</ol>
<p>Error Handling:
- If the Feat does not exist, returns <code>{"status": "error", "message": "Feat not found."}</code>.
- On other exceptions, returns <code>{"status": "error", "message": &lt;error message&gt;}</code>.
- Non-POST requests return HTTP 400 with <code>{"status": "error", "message": "Invalid request method."}</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be POST with a JSON body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>
<ul>
<li>On success: <code>{"status": "success"}</code> (HTTP 200).</li>
<li>On error:
<code>{"status": "error", "message": &lt;details&gt;}</code>.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.edit_column"><code class="name flex">
<span>def <span class="ident">edit_column</span></span>(<span>request, column_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def edit_column(request, column_name):
    &#34;&#34;&#34;
    Update a specified column for all EPV asset records sharing the same QC1 value via JSON POST.

    Expects a POST request with a JSON body containing:
      - id (int):        The primary key of the `quality_epv_assets` record whose QC1 is used for grouping.
      - old_value (str): The original value in the specified column (for logging/validation).
      - new_value (str): The new value to set in the specified column.

    Workflow:
      1. Parse and validate the JSON payload; return HTTP 400 if any required field is missing or JSON is invalid.
      2. Log the action, including `epv_id`, `column_name`, `old_value`, and `new_value`.
      3. Invoke `edit_related_column_by_qc1(epv_id, column_name, new_value)` to:
         • Retrieve the QC1 value for `epv_id`.
         • Find all rows in `quality_epv_assets` with that QC1.
         • Bulk-update the specified column to `new_value`.
         • Return a list of IDs that were updated.
      4. Return HTTP 200 with a message indicating success and the list of updated record IDs.
      5. Non-POST requests return HTTP 405 with `{&#34;error&#34;: &#34;Invalid request method&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be POST with a JSON body.
    column_name : str
        The name of the column in `quality_epv_assets` to update.

    Returns
    -------
    django.http.JsonResponse
        - On success: `{&#34;message&#34;: &#34;&lt;column_name&gt; updated for all related entries&#34;, &#34;updated_ids&#34;: [&lt;ids&gt;]}` (HTTP 200).
        - On missing data or invalid JSON: `{&#34;error&#34;: &#34;Missing data&#34;}` or `{&#34;error&#34;: &#34;Invalid JSON&#34;}` (HTTP 400).
        - On invalid method: `{&#34;error&#34;: &#34;Invalid request method&#34;}` (HTTP 405).
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        try:
            data = json.loads(request.body)
            epv_id = data.get(&#34;id&#34;)
            old_value = data.get(&#34;old_value&#34;)
            new_value = data.get(&#34;new_value&#34;)

            if not epv_id or not old_value or not new_value:
                return JsonResponse({&#34;error&#34;: &#34;Missing data&#34;}, status=400)

            print(f&#34;EPV ID: {epv_id}, Column: {column_name}, Old Value: {old_value}, New Value: {new_value}&#34;)

            # Call function to update related column values
            updated_ids = edit_related_column_by_qc1(epv_id, column_name, new_value)

            return JsonResponse({&#34;message&#34;: f&#34;{column_name} updated for all related entries&#34;, &#34;updated_ids&#34;: updated_ids}, status=200)

        except json.JSONDecodeError:
            return JsonResponse({&#34;error&#34;: &#34;Invalid JSON&#34;}, status=400)

    return JsonResponse({&#34;error&#34;: &#34;Invalid request method&#34;}, status=405)</code></pre>
</details>
<div class="desc"><p>Update a specified column for all EPV asset records sharing the same QC1 value via JSON POST.</p>
<p>Expects a POST request with a JSON body containing:
- id (int):
The primary key of the <code>quality_epv_assets</code> record whose QC1 is used for grouping.
- old_value (str): The original value in the specified column (for logging/validation).
- new_value (str): The new value to set in the specified column.</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse and validate the JSON payload; return HTTP 400 if any required field is missing or JSON is invalid.</li>
<li>Log the action, including <code>epv_id</code>, <code>column_name</code>, <code>old_value</code>, and <code>new_value</code>.</li>
<li>Invoke <code><a title="quality.views.edit_related_column_by_qc1" href="#quality.views.edit_related_column_by_qc1">edit_related_column_by_qc1()</a>(epv_id, column_name, new_value)</code> to:
• Retrieve the QC1 value for <code>epv_id</code>.
• Find all rows in <code>quality_epv_assets</code> with that QC1.
• Bulk-update the specified column to <code>new_value</code>.
• Return a list of IDs that were updated.</li>
<li>Return HTTP 200 with a message indicating success and the list of updated record IDs.</li>
<li>Non-POST requests return HTTP 405 with <code>{"error": "Invalid request method"}</code>.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be POST with a JSON body.</dd>
<dt><strong><code>column_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column in <code>quality_epv_assets</code> to update.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>
<ul>
<li>On success: <code>{"message": "&lt;column_name&gt; updated for all related entries", "updated_ids": [&lt;ids&gt;]}</code> (HTTP 200).</li>
<li>On missing data or invalid JSON: <code>{"error": "Missing data"}</code> or <code>{"error": "Invalid JSON"}</code> (HTTP 400).</li>
<li>On invalid method: <code>{"error": "Invalid request method"}</code> (HTTP 405).</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.edit_related_column_by_qc1"><code class="name flex">
<span>def <span class="ident">edit_related_column_by_qc1</span></span>(<span>epv_id, column_name, new_value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_related_column_by_qc1(epv_id, column_name, new_value):
    &#34;&#34;&#34;
    Update a specified column for all rows sharing the same QC1 group as a given record.

    This function:
      1. Connects to the database using `get_creds()`.
      2. Retrieves the `QC1` value for the row with primary key `epv_id`.
      3. Executes an UPDATE statement setting `column_name = new_value`
         for every row in `quality_epv_assets` with that same `QC1`.
      4. Commits the transaction and returns a list containing the
         original `epv_id` on success.
      5. Returns an empty list if the initial row is not found or if any
         database error occurs.

    Parameters
    ----------
    epv_id : int
        The primary key of the reference record whose QC1 value determines
        the group to update.
    column_name : str
        The name of the column to update (must match a valid column in
        `quality_epv_assets`).
    new_value : Any
        The new value to assign to `column_name` for all matching rows.

    Returns
    -------
    list[int]
        A single-element list `[epv_id]` if the update succeeded, or an
        empty list if no matching record was found or an error occurred.

    Notes
    -----
    - Relies on `get_creds()` to supply a valid, open database connection.
    - Uses a raw SQL query; ensure `column_name` is trusted or validated
      to avoid SQL injection risks.
    &#34;&#34;&#34;
    try:
        connection = get_creds()
        if connection.is_connected():
            cursor = connection.cursor()

            # Get QC1 value
            cursor.execute(&#34;SELECT QC1 FROM quality_epv_assets WHERE id = %s&#34;, (epv_id,))
            result = cursor.fetchone()

            if not result:
                return []

            qc1_value = result[0]

            # Update column for all matching QC1 values
            query = f&#34;UPDATE quality_epv_assets SET {column_name} = %s WHERE QC1 = %s&#34;
            cursor.execute(query, (new_value, qc1_value))
            connection.commit()

            return [epv_id]

    except Exception as e:
        print(f&#34;Database error: {e}&#34;)
        return []
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()</code></pre>
</details>
<div class="desc"><p>Update a specified column for all rows sharing the same QC1 group as a given record.</p>
<p>This function:
1. Connects to the database using <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code>.
2. Retrieves the <code>QC1</code> value for the row with primary key <code>epv_id</code>.
3. Executes an UPDATE statement setting <code>column_name = new_value</code>
for every row in <code>quality_epv_assets</code> with that same <code>QC1</code>.
4. Commits the transaction and returns a list containing the
original <code>epv_id</code> on success.
5. Returns an empty list if the initial row is not found or if any
database error occurs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>epv_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the reference record whose QC1 value determines
the group to update.</dd>
<dt><strong><code>column_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column to update (must match a valid column in
<code>quality_epv_assets</code>).</dd>
<dt><strong><code>new_value</code></strong> :&ensp;<code>Any</code></dt>
<dd>The new value to assign to <code>column_name</code> for all matching rows.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[int]</code></dt>
<dd>A single-element list <code>[epv_id]</code> if the update succeeded, or an
empty list if no matching record was found or an error occurred.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Relies on <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code> to supply a valid, open database connection.</li>
<li>Uses a raw SQL query; ensure <code>column_name</code> is trusted or validated
to avoid SQL injection risks.</li>
</ul></div>
</dd>
<dt id="quality.views.epv_table_view"><code class="name flex">
<span>def <span class="ident">epv_table_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@login_required(login_url=&#39;/login/&#39;)
def epv_table_view(request):
    # Check if the user is in the &#39;quality_manager&#39; group.
    if not request.user.groups.filter(name=&#39;quality_manager&#39;).exists():
        return HttpResponseForbidden(&#34;Only EPV admins are authorized to access this page. If you require access, please request an admin to add you to Quality_Managers group&#34;)
    
    # Call get_creds to verify the settings.py file can be found.
    settings_file = get_creds()
    # if settings_file:
    #     # print(f&#34;Using settings.py at: {settings_file}&#34;)
    # else:
    #     print(&#34;Could not locate settings.py.&#34;)

    table_data = get_all_data()
    return render(request, &#39;quality/epv_interface.html&#39;, {&#39;table_data&#39;: table_data})</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="quality.views.feat_create"><code class="name flex">
<span>def <span class="ident">feat_create</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feat_create(request):
    &#34;&#34;&#34;
    Create a new Feat entry, optionally pre-associating it with a Part.

    - GET:
        • If `part_id` is provided as a query parameter, fetch the corresponding Part
          (404 if not found), compute the next `order` as (existing count + 1),
          and instantiate FeatForm with initial `part` and `order`.
        • Otherwise, instantiate an empty FeatForm.
        • Render &#39;quality/feat_form.html&#39; with the form.

    - POST:
        • Bind FeatForm with request.POST.
        • If valid, save the new Feat within an atomic transaction
          (ensuring referential integrity).
        • Redirect to the &#39;scrap_form_management&#39; view on success.
        • If invalid, re-render the form with errors.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, may include:
          - GET parameter `part_id` (int) for pre-association.
          - POST data matching the FeatForm fields.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or invalid POST: renders &#39;quality/feat_form.html&#39; with `form` context.
        - On successful POST: redirects to &#39;scrap_form_management&#39;.
    &#34;&#34;&#34;
    part_id = request.GET.get(&#39;part_id&#39;)  # Retrieve the part ID from the query parameters
    if request.method == &#39;POST&#39;:
        form = FeatForm(request.POST)
        if form.is_valid():
            with transaction.atomic():  # Ensure atomic transaction
                # Save the new feat without adjusting orders
                form.save()
            return redirect(&#39;scrap_form_management&#39;)
    else:
        if part_id:
            part = get_object_or_404(Part, id=part_id)
            # Calculate the next order number
            next_order = part.feat_set.count() + 1
            form = FeatForm(initial={&#39;part&#39;: part, &#39;order&#39;: next_order})  # Pre-fill part and order
        else:
            form = FeatForm()
    
    return render(request, &#39;quality/feat_form.html&#39;, {&#39;form&#39;: form})</code></pre>
</details>
<div class="desc"><p>Create a new Feat entry, optionally pre-associating it with a Part.</p>
<ul>
<li>
<p>GET:
• If <code>part_id</code> is provided as a query parameter, fetch the corresponding Part
(404 if not found), compute the next <code>order</code> as (existing count + 1),
and instantiate FeatForm with initial <code>part</code> and <code>order</code>.
• Otherwise, instantiate an empty FeatForm.
• Render 'quality/feat_form.html' with the form.</p>
</li>
<li>
<p>POST:
• Bind FeatForm with request.POST.
• If valid, save the new Feat within an atomic transaction
(ensuring referential integrity).
• Redirect to the 'scrap_form_management' view on success.
• If invalid, re-render the form with errors.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, may include:
- GET parameter <code>part_id</code> (int) for pre-association.
- POST data matching the FeatForm fields.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or invalid POST: renders 'quality/feat_form.html' with <code>form</code> context.</li>
<li>On successful POST: redirects to 'scrap_form_management'.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.feat_delete"><code class="name flex">
<span>def <span class="ident">feat_delete</span></span>(<span>request, pk)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feat_delete(request, pk):
    &#34;&#34;&#34;
    Delete an existing Feat entry without reordering remaining feats.

    - GET:
        • Retrieve the Feat by primary key (404 if not found).
        • Render &#39;quality/feat_confirm_delete.html&#39; to confirm deletion.

    - POST:
        • Delete the Feat instance.
        • Redirect to the &#39;scrap_form_management&#39; view.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request.
    pk : int
        The primary key of the Feat to delete.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET: renders &#39;quality/feat_confirm_delete.html&#39; with `feat` context.
        - On POST: redirects to &#39;scrap_form_management&#39; after deletion.
    &#34;&#34;&#34;
    feat = get_object_or_404(Feat, pk=pk)

    if request.method == &#39;POST&#39;:
        # Simply delete the feat without adjusting the orders of remaining feats
        feat.delete()
        return redirect(&#39;scrap_form_management&#39;)
    
    return render(request, &#39;quality/feat_confirm_delete.html&#39;, {&#39;feat&#39;: feat})</code></pre>
</details>
<div class="desc"><p>Delete an existing Feat entry without reordering remaining feats.</p>
<ul>
<li>
<p>GET:
• Retrieve the Feat by primary key (404 if not found).
• Render 'quality/feat_confirm_delete.html' to confirm deletion.</p>
</li>
<li>
<p>POST:
• Delete the Feat instance.
• Redirect to the 'scrap_form_management' view.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request.</dd>
<dt><strong><code>pk</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the Feat to delete.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET: renders 'quality/feat_confirm_delete.html' with <code>feat</code> context.</li>
<li>On POST: redirects to 'scrap_form_management' after deletion.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.feat_move_down"><code class="name flex">
<span>def <span class="ident">feat_move_down</span></span>(<span>request, pk)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feat_move_down(request, pk):
    &#34;&#34;&#34;
    Shift a Feat’s display order down by one position within its Part.

    Retrieves the Feat identified by `pk`. If its `order` is less than the
    count of feats for that Part, performs an atomic swap:
      1. Decrements the `order` of the sibling Feat immediately below
         (current order + 1).
      2. Increments this Feat’s `order` by 1 and saves it.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request (typically AJAX).
    pk : int
        The primary key of the Feat to move downward.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success: `{&#39;success&#39;: True}`.
    &#34;&#34;&#34;
    feat = get_object_or_404(Feat, pk=pk)
    max_order = feat.part.feat_set.count()
    if feat.order &lt; max_order:
        with transaction.atomic():
            # Increment the order of the feat just below
            Feat.objects.filter(part=feat.part, order=feat.order + 1).update(order=F(&#39;order&#39;) - 1)
            # Move this feat down
            feat.order += 1
            feat.save()
    return JsonResponse({&#39;success&#39;: True})</code></pre>
</details>
<div class="desc"><p>Shift a Feat’s display order down by one position within its Part.</p>
<p>Retrieves the Feat identified by <code>pk</code>. If its <code>order</code> is less than the
count of feats for that Part, performs an atomic swap:
1. Decrements the <code>order</code> of the sibling Feat immediately below
(current order + 1).
2. Increments this Feat’s <code>order</code> by 1 and saves it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request (typically AJAX).</dd>
<dt><strong><code>pk</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the Feat to move downward.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success: <code>{'success': True}</code>.</dd>
</dl></div>
</dd>
<dt id="quality.views.feat_move_up"><code class="name flex">
<span>def <span class="ident">feat_move_up</span></span>(<span>request, pk)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feat_move_up(request, pk):
    &#34;&#34;&#34;
    Shift a Feat’s display order up by one position within its Part.

    Retrieves the Feat identified by `pk`. If its `order` is greater than 1,
    performs an atomic swap:
      1. Increments the `order` of the sibling Feat immediately above
         (current order − 1).
      2. Decrements this Feat’s `order` by 1 and saves it.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request (typically AJAX).
    pk : int
        The primary key of the Feat to move upward.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success: `{&#39;success&#39;: True}`.
    &#34;&#34;&#34;
    feat = get_object_or_404(Feat, pk=pk)
    if feat.order &gt; 1:
        with transaction.atomic():
            # Decrement the order of the feat just above
            Feat.objects.filter(part=feat.part, order=feat.order - 1).update(order=F(&#39;order&#39;) + 1)
            # Move this feat up
            feat.order -= 1
            feat.save()
    return JsonResponse({&#39;success&#39;: True})</code></pre>
</details>
<div class="desc"><p>Shift a Feat’s display order up by one position within its Part.</p>
<p>Retrieves the Feat identified by <code>pk</code>. If its <code>order</code> is greater than 1,
performs an atomic swap:
1. Increments the <code>order</code> of the sibling Feat immediately above
(current order − 1).
2. Decrements this Feat’s <code>order</code> by 1 and saves it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request (typically AJAX).</dd>
<dt><strong><code>pk</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the Feat to move upward.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success: <code>{'success': True}</code>.</dd>
</dl></div>
</dd>
<dt id="quality.views.feat_update"><code class="name flex">
<span>def <span class="ident">feat_update</span></span>(<span>request, pk)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feat_update(request, pk):
    &#34;&#34;&#34;
    Edit an existing Feat entry.

    - GET:
        • Retrieve the Feat by primary key (404 if not found).
        • Instantiate FeatForm with the existing instance.
        • Render &#39;quality/feat_form.html&#39; with the form for editing.

    - POST:
        • Bind FeatForm to request.POST and the existing `feat` instance.
        • If valid, save updates (without reordering other feats).
        • Redirect to the &#39;scrap_form_management&#39; view on success.
        • If invalid, re-render the form with validation errors.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request.
    pk : int
        The primary key of the Feat to update.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or invalid POST: renders &#39;quality/feat_form.html&#39; with `form` context.
        - On successful POST: redirects to &#39;scrap_form_management&#39;.
    &#34;&#34;&#34;
    feat = get_object_or_404(Feat, pk=pk)
    if request.method == &#39;POST&#39;:
        form = FeatForm(request.POST, instance=feat)
        if form.is_valid():
            # Save the updated feat without adjusting orders
            form.save()
            return redirect(&#39;scrap_form_management&#39;)
    else:
        form = FeatForm(instance=feat)
    return render(request, &#39;quality/feat_form.html&#39;, {&#39;form&#39;: form})</code></pre>
</details>
<div class="desc"><p>Edit an existing Feat entry.</p>
<ul>
<li>
<p>GET:
• Retrieve the Feat by primary key (404 if not found).
• Instantiate FeatForm with the existing instance.
• Render 'quality/feat_form.html' with the form for editing.</p>
</li>
<li>
<p>POST:
• Bind FeatForm to request.POST and the existing <code>feat</code> instance.
• If valid, save updates (without reordering other feats).
• Redirect to the 'scrap_form_management' view on success.
• If invalid, re-render the form with validation errors.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request.</dd>
<dt><strong><code>pk</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the Feat to update.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or invalid POST: renders 'quality/feat_form.html' with <code>form</code> context.</li>
<li>On successful POST: redirects to 'scrap_form_management'.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.fetch_all_data"><code class="name flex">
<span>def <span class="ident">fetch_all_data</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_all_data(request):
    return JsonResponse({&#39;table_data&#39;: get_all_data()}, safe=False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="quality.views.fetch_related_persons"><code class="name flex">
<span>def <span class="ident">fetch_related_persons</span></span>(<span>epv_id, new_person)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_related_persons(epv_id, new_person):
    &#34;&#34;&#34;
    Update the `Person` field for all EPV asset records sharing the same QC1 value.

    This function:
      1. Connects to the MySQL database using `get_creds()`.
      2. Retrieves the `QC1` value for the record with the given `epv_id`.
      3. Queries all rows in `quality_epv_assets` having that same `QC1`.
      4. Prints each matching record’s ID and old Person value, and the intended new value.
      5. Executes a bulk UPDATE to set `Person = new_person` for all those rows.
      6. Commits the transaction and closes the connection.

    Parameters
    ----------
    epv_id : int
        The primary key of the `quality_epv_assets` record whose `QC1` will be used as the grouping key.
    new_person : str
        The new name to assign to the `Person` field on all related records.

    Returns
    -------
    None

    Notes
    -----
    - Logs progress and errors via `print()`.
    - If no record is found for `epv_id`, the function prints a message and returns without error.
    - Database errors are caught and printed; no exception is propagated.
    &#34;&#34;&#34;
    try:
        connection = get_creds()
        if connection.is_connected():
            cursor = connection.cursor(dictionary=True)

            # Step 1: Get the QC1 value for the given ID
            cursor.execute(&#34;SELECT QC1 FROM quality_epv_assets WHERE id = %s&#34;, (epv_id,))
            result = cursor.fetchone()

            if not result:
                print(f&#34;No entry found for ID: {epv_id}&#34;)
                return

            qc1_value = result[&#34;QC1&#34;]
            print(f&#34;QC1 for ID {epv_id}: {qc1_value}&#34;)

            # Step 2: Find all entries with the same QC1
            cursor.execute(&#34;SELECT id, Person FROM quality_epv_assets WHERE QC1 = %s&#34;, (qc1_value,))
            related_entries = cursor.fetchall()

            print(&#34;Updating the following entries with new Person name:&#34;)
            for entry in related_entries:
                print(f&#34;ID: {entry[&#39;id&#39;]}, Old Person: {entry[&#39;Person&#39;]} → New Person: {new_person}&#34;)

            # Step 3: Update the Person field for all related entries
            cursor.execute(&#34;UPDATE quality_epv_assets SET Person = %s WHERE QC1 = %s&#34;, (new_person, qc1_value))
            connection.commit()

            print(&#34;Person field updated successfully for all related entries.&#34;)

    except Error as e:
        print(f&#34;Database error: {e}&#34;)
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()</code></pre>
</details>
<div class="desc"><p>Update the <code>Person</code> field for all EPV asset records sharing the same QC1 value.</p>
<p>This function:
1. Connects to the MySQL database using <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code>.
2. Retrieves the <code>QC1</code> value for the record with the given <code>epv_id</code>.
3. Queries all rows in <code>quality_epv_assets</code> having that same <code>QC1</code>.
4. Prints each matching record’s ID and old Person value, and the intended new value.
5. Executes a bulk UPDATE to set <code>Person = new_person</code> for all those rows.
6. Commits the transaction and closes the connection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>epv_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the <code>quality_epv_assets</code> record whose <code>QC1</code> will be used as the grouping key.</dd>
<dt><strong><code>new_person</code></strong> :&ensp;<code>str</code></dt>
<dd>The new name to assign to the <code>Person</code> field on all related records.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Logs progress and errors via <code>print()</code>.</li>
<li>If no record is found for <code>epv_id</code>, the function prints a message and returns without error.</li>
<li>Database errors are caught and printed; no exception is propagated.</li>
</ul></div>
</dd>
<dt id="quality.views.final_inspection"><code class="name flex">
<span>def <span class="ident">final_inspection</span></span>(<span>request, part_number)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def final_inspection(request, part_number):
    &#34;&#34;&#34;
    Render the final inspection scrap form for a specific part.

    Retrieves the Part identified by `part_number` (returning 404 if not found),
    then fetches all associated Feat records. Renders the
    &#39;quality/scrap_form.html&#39; template with:
      - `part`: the Part instance under inspection
      - `feats`: a QuerySet of Feat objects linked to that Part

    Parameters
    ----------
    request : django.http.HttpRequest
        The HTTP request object.
    part_number : str
        The unique identifier for the Part to inspect.

    Returns
    -------
    django.http.HttpResponse
        The rendered scrap form page populated with the part and its feats.
    &#34;&#34;&#34;
    # Get the Part object based on the part_number
    part = get_object_or_404(Part, part_number=part_number)
    
    # Get all feats associated with this part
    feats = part.feat_set.all()

    # Pass the feats and part to the template
    return render(request, &#39;quality/scrap_form.html&#39;, {&#39;part&#39;: part, &#39;feats&#39;: feats})</code></pre>
</details>
<div class="desc"><p>Render the final inspection scrap form for a specific part.</p>
<p>Retrieves the Part identified by <code>part_number</code> (returning 404 if not found),
then fetches all associated Feat records. Renders the
'quality/scrap_form.html' template with:
- <code>part</code>: the Part instance under inspection
- <code>feats</code>: a QuerySet of Feat objects linked to that Part</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The HTTP request object.</dd>
<dt><strong><code>part_number</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique identifier for the Part to inspect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code></dt>
<dd>The rendered scrap form page populated with the part and its feats.</dd>
</dl></div>
</dd>
<dt id="quality.views.forms_page"><code class="name flex">
<span>def <span class="ident">forms_page</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forms_page(request):
    &#34;&#34;&#34;
    Display a part selection page or redirect to the final inspection form.

    - GET:
        • Fetch all Part instances.
        • Render &#39;quality/forms_page.html&#39; with context:
            - `parts`: QuerySet of available Part objects.
    - POST:
        • Read `selected_part` from submitted form data.
        • If provided, redirect to the `final_inspection` view for that part_number.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, which may be GET or POST with form data.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or missing selection: renders the part-selection template.
        - On valid POST with `selected_part`: redirects to `final_inspection`.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        selected_part = request.POST.get(&#39;selected_part&#39;)
        if selected_part:
            # Redirect to the scrap_form view with the selected part number
            return redirect(&#39;final_inspection&#39;, part_number=selected_part)
    
    # If it&#39;s a GET request, just render the form selection page
    parts = Part.objects.all()
    return render(request, &#39;quality/forms_page.html&#39;, {&#39;parts&#39;: parts})</code></pre>
</details>
<div class="desc"><p>Display a part selection page or redirect to the final inspection form.</p>
<ul>
<li>GET:
• Fetch all Part instances.
• Render 'quality/forms_page.html' with context:
- <code>parts</code>: QuerySet of available Part objects.</li>
<li>POST:
• Read <code>selected_part</code> from submitted form data.
• If provided, redirect to the <code><a title="quality.views.final_inspection" href="#quality.views.final_inspection">final_inspection()</a></code> view for that part_number.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, which may be GET or POST with form data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or missing selection: renders the part-selection template.</li>
<li>On valid POST with <code>selected_part</code>: redirects to <code><a title="quality.views.final_inspection" href="#quality.views.final_inspection">final_inspection()</a></code>.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.get_all_data"><code class="name flex">
<span>def <span class="ident">get_all_data</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_data():
    &#34;&#34;&#34;
    Retrieve all records from the `quality_epv_assets` table as dictionaries.

    Establishes a MySQL connection via `get_creds()`, then executes a SELECT query
    to fetch the columns `id, QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset`.
    Each row is returned as a dict (`cursor(dictionary=True)`), and the `Asset` value
    is post-processed by `remove_zeros()` to strip any trailing “.0” suffix.

    Error Handling
    --------------
    - If the connection cannot be established or the query fails, logs the error
      to stdout and returns an empty list.
    - Ensures that the database cursor and connection are closed in all cases.

    Returns
    -------
    list of dict
        A list of row dictionaries with keys matching the selected columns. Returns
        an empty list if a database error occurs or if `get_creds()` fails.
    &#34;&#34;&#34;
    try:
        connection = get_creds()
        if connection.is_connected():
            cursor = connection.cursor(dictionary=True)
            query = &#34;&#34;&#34;
                SELECT id, QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset 
                FROM quality_epv_assets
            &#34;&#34;&#34;
            cursor.execute(query)
            data = cursor.fetchall()

            # Process assets to remove trailing &#34;.0&#34;
            for row in data:
                row[&#34;Asset&#34;] = remove_zeros(row[&#34;Asset&#34;])

            return data
    except Error as e:
        print(f&#34;Database error: {e}&#34;)
        return []
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()</code></pre>
</details>
<div class="desc"><p>Retrieve all records from the <code>quality_epv_assets</code> table as dictionaries.</p>
<p>Establishes a MySQL connection via <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code>, then executes a SELECT query
to fetch the columns <code>id, QC1, OP1, Check1, Desc1, Method1, Interval1, Person, Asset</code>.
Each row is returned as a dict (<code>cursor(dictionary=True)</code>), and the <code>Asset</code> value
is post-processed by <code><a title="quality.views.remove_zeros" href="#quality.views.remove_zeros">remove_zeros()</a></code> to strip any trailing “.0” suffix.</p>
<h2 id="error-handling">Error Handling</h2>
<ul>
<li>If the connection cannot be established or the query fails, logs the error
to stdout and returns an empty list.</li>
<li>Ensures that the database cursor and connection are closed in all cases.</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>dict</code></dt>
<dd>A list of row dictionaries with keys matching the selected columns. Returns
an empty list if a database error occurs or if <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code> fails.</dd>
</dl></div>
</dd>
<dt id="quality.views.get_creds"><code class="name flex">
<span>def <span class="ident">get_creds</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_creds():
    &#34;&#34;&#34;
    Load DAVE_* database credentials from the Django settings module and return a MySQL connection.

    This function locates the `settings.py` file in the sibling `pms` package directory,
    dynamically imports it, and reads the attributes `DAVE_HOST`, `DAVE_USER`,
    `DAVE_PASSWORD`, and `DAVE_DB`. If all credentials are found, it attempts to
    establish and return a `mysql.connector` connection to the specified database.
    On any failure (missing file, missing attributes, or connection error), it logs
    a message and returns `None`.

    Returns
    -------
    mysql.connector.MySQLConnection or None
        A live MySQL connection if successful; otherwise `None`.

    Notes
    -----
    - Expects `settings.py` at `../pms/settings.py` relative to this script.
    - Credentials must be defined as module-level variables named:
      `DAVE_HOST`, `DAVE_USER`, `DAVE_PASSWORD`, and `DAVE_DB`.
    - Uses dynamic import via `importlib.util`.
    - Errors are printed to stdout; no exceptions are propagated.
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    Dynamically loads database credentials (DAVE_*) from settings.py and returns a MySQL connection object.
    &#34;&#34;&#34;
    # Find the directory of this script
    current_dir = os.path.dirname(os.path.abspath(__file__))

    # Construct the path to settings.py
    settings_path = os.path.join(current_dir, &#39;..&#39;, &#39;pms&#39;, &#39;settings.py&#39;)

    if not os.path.exists(settings_path):
        print(f&#34;settings.py not found at: {settings_path}&#34;)
        return None

    # Dynamically import settings.py
    spec = importlib.util.spec_from_file_location(&#34;settings&#34;, settings_path)
    settings = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(settings)

    # Extract the database credentials
    dave_host = getattr(settings, &#34;DAVE_HOST&#34;, None)
    dave_user = getattr(settings, &#34;DAVE_USER&#34;, None)
    dave_password = getattr(settings, &#34;DAVE_PASSWORD&#34;, None)
    dave_db = getattr(settings, &#34;DAVE_DB&#34;, None)

    # Validate that all credentials are present
    if not all([dave_host, dave_user, dave_password, dave_db]):
        # print(&#34;Missing database credentials in settings.py&#34;)
        return None

    try:
        # Return a MySQL connection object
        connection = mysql.connector.connect(
            host=dave_host,
            user=dave_user,
            password=dave_password,
            database=dave_db
        )
        # print(&#34;Successfully connected to the database&#34;)
        return connection

    except Error as e:
        print(f&#34;❌ Database connection error: {e}&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>Load DAVE_* database credentials from the Django settings module and return a MySQL connection.</p>
<p>This function locates the <code>settings.py</code> file in the sibling <code>pms</code> package directory,
dynamically imports it, and reads the attributes <code>DAVE_HOST</code>, <code>DAVE_USER</code>,
<code>DAVE_PASSWORD</code>, and <code>DAVE_DB</code>. If all credentials are found, it attempts to
establish and return a <code>mysql.connector</code> connection to the specified database.
On any failure (missing file, missing attributes, or connection error), it logs
a message and returns <code>None</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>mysql.connector.MySQLConnection</code> or <code>None</code></dt>
<dd>A live MySQL connection if successful; otherwise <code>None</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Expects <code>settings.py</code> at <code>../pms/settings.py</code> relative to this script.</li>
<li>Credentials must be defined as module-level variables named:
<code>DAVE_HOST</code>, <code>DAVE_USER</code>, <code>DAVE_PASSWORD</code>, and <code>DAVE_DB</code>.</li>
<li>Uses dynamic import via <code>importlib.util</code>.</li>
<li>Errors are printed to stdout; no exceptions are propagated.</li>
</ul></div>
</dd>
<dt id="quality.views.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(request):
    is_quality_manager = False
    if request.user.is_authenticated:
        is_quality_manager = request.user.groups.filter(name=&#34;quality_manager&#34;).exists()
    context = {
        &#39;is_quality_manager&#39;: is_quality_manager,
        # ... any other context variables ...
    }
    return render(request, &#39;quality/index.html&#39;, context)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="quality.views.manage_red_rabbit_types"><code class="name flex">
<span>def <span class="ident">manage_red_rabbit_types</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@login_required(login_url=&#34;login&#34;)
def manage_red_rabbit_types(request):
    &#34;&#34;&#34;
    List, add, edit, and delete RedRabbitType entries for HR managers.

    Access Control
    --------------
    Requires authentication; unauthenticated users are redirected to the &#34;login&#34; page.

    Behavior
    --------
    - GET:
        • Fetch all Part instances for the part-selection dropdown.
        • Retrieve all RedRabbitType records (with related Part) to display.
        • Instantiate an empty `add_form` (RedRabbitTypeForm).
        • No `edit_form` unless triggered by POST.

    - POST with `action == &#39;add&#39;`:
        • Bind `add_form` to submitted data.
        • If valid, save a new RedRabbitType and redirect back to this view.
        • Otherwise, fall through to re-render with validation errors.

    - POST with `action == &#39;edit&#39;`:
        • Retrieve the target RedRabbitType via `edit_id`; 404 if not found.
        • Bind `edit_form` to submitted data and instance.
        • If valid, save updates and redirect back to this view.
        • Otherwise, re-render with both `add_form` and the invalid `edit_form`.

    - POST with `action == &#39;delete&#39;`:
        • Retrieve the RedRabbitType via `delete_id`; 404 if not found.
        • Delete the record and redirect back to this view.

    Context
    -------
    Renders &#39;quality/manage_red_rabbit_types.html&#39; with:
      - `rabbit_types`: QuerySet of all RedRabbitType objects (with Part).
      - `parts`: QuerySet of all Part objects for dropdowns.
      - `add_form`: instance of RedRabbitTypeForm for creating new entries.
      - `edit_form`: instance of RedRabbitTypeForm for editing (or None).

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, supporting GET and POST with form actions.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or form validation failure: renders the management template.
        - On successful add/edit/delete: redirects to the same management view.
    &#34;&#34;&#34;
    # Fetch all parts to populate the dropdown
    parts = Part.objects.all()

    # Handle adding a new Red Rabbit Type
    if request.method == &#39;POST&#39; and request.POST.get(&#39;action&#39;) == &#39;add&#39;:
        add_form = RedRabbitTypeForm(request.POST)
        if add_form.is_valid():
            add_form.save()
            return redirect(&#39;manage_red_rabbit_types&#39;)
    else:
        add_form = RedRabbitTypeForm()

    # Handle editing an existing Red Rabbit Type
    if request.method == &#39;POST&#39; and request.POST.get(&#39;action&#39;) == &#39;edit&#39;:
        edit_id = request.POST.get(&#39;edit_id&#39;)
        rabbit_type = get_object_or_404(RedRabbitType, pk=edit_id)
        edit_form = RedRabbitTypeForm(request.POST, instance=rabbit_type)
        if edit_form.is_valid():
            edit_form.save()
            return redirect(&#39;manage_red_rabbit_types&#39;)
    else:
        edit_form = None

    # Handle deleting a Red Rabbit Type
    if request.method == &#39;POST&#39; and request.POST.get(&#39;action&#39;) == &#39;delete&#39;:
        delete_id = request.POST.get(&#39;delete_id&#39;)
        rabbit_type = get_object_or_404(RedRabbitType, pk=delete_id)
        rabbit_type.delete()
        return redirect(&#39;manage_red_rabbit_types&#39;)

    # Retrieve all Red Rabbit Types
    rabbit_types = RedRabbitType.objects.select_related(&#39;part&#39;).all()

    return render(request, &#39;quality/manage_red_rabbit_types.html&#39;, {
        &#39;rabbit_types&#39;: rabbit_types,
        &#39;parts&#39;: parts,  # Include parts in the context
        &#39;add_form&#39;: add_form,
        &#39;edit_form&#39;: edit_form,
    })</code></pre>
</details>
<div class="desc"><p>List, add, edit, and delete RedRabbitType entries for HR managers.</p>
<h2 id="access-control">Access Control</h2>
<p>Requires authentication; unauthenticated users are redirected to the "login" page.</p>
<h2 id="behavior">Behavior</h2>
<ul>
<li>
<p>GET:
• Fetch all Part instances for the part-selection dropdown.
• Retrieve all RedRabbitType records (with related Part) to display.
• Instantiate an empty <code>add_form</code> (RedRabbitTypeForm).
• No <code>edit_form</code> unless triggered by POST.</p>
</li>
<li>
<p>POST with <code>action == 'add'</code>:
• Bind <code>add_form</code> to submitted data.
• If valid, save a new RedRabbitType and redirect back to this view.
• Otherwise, fall through to re-render with validation errors.</p>
</li>
<li>
<p>POST with <code>action == 'edit'</code>:
• Retrieve the target RedRabbitType via <code>edit_id</code>; 404 if not found.
• Bind <code>edit_form</code> to submitted data and instance.
• If valid, save updates and redirect back to this view.
• Otherwise, re-render with both <code>add_form</code> and the invalid <code>edit_form</code>.</p>
</li>
<li>
<p>POST with <code>action == 'delete'</code>:
• Retrieve the RedRabbitType via <code>delete_id</code>; 404 if not found.
• Delete the record and redirect back to this view.</p>
</li>
</ul>
<h2 id="context">Context</h2>
<p>Renders 'quality/manage_red_rabbit_types.html' with:
- <code>rabbit_types</code>: QuerySet of all RedRabbitType objects (with Part).
- <code>parts</code>: QuerySet of all Part objects for dropdowns.
- <code>add_form</code>: instance of RedRabbitTypeForm for creating new entries.
- <code>edit_form</code>: instance of RedRabbitTypeForm for editing (or None).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, supporting GET and POST with form actions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or form validation failure: renders the management template.</li>
<li>On successful add/edit/delete: redirects to the same management view.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.mark_pdf_as_viewed"><code class="name flex">
<span>def <span class="ident">mark_pdf_as_viewed</span></span>(<span>request, pdf_id, clock_number)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_pdf_as_viewed(request, pdf_id, clock_number):
    &#34;&#34;&#34;
    Record that a user (identified by clock_number) has viewed a PDF and redirect back to the review list.

    Expects:
      - `pdf_id` (int):       The primary key of the QualityPDFDocument to mark as viewed.
      - `clock_number` (str): The operator’s clock number performing the view action.
      - Optional GET parameters:
          • `part_number` (str): Comma-separated Part identifier to maintain context.
          • `clock_numbers` (str): Comma-separated list of all clock numbers in the session.

    Workflow:
      1. Retrieve the QualityPDFDocument by `pdf_id` or return 404.
      2. Create a new ViewingRecord linking `operator_number` and the PDF.
      3. Determine `part_number` from GET or fall back to the document’s first associated part.
      4. Determine the full `clock_numbers` list from GET or default to the current `clock_number`.
      5. Redirect to `pdfs_to_view` with `part_number` and `clock_numbers` to continue the review process.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request.
    pdf_id : int
        ID of the PDF document being marked viewed.
    clock_number : str
        Operator’s clock number.

    Returns
    -------
    django.http.HttpResponseRedirect
        Redirects to the `pdfs_to_view` view with the appropriate query parameters.
    &#34;&#34;&#34;
    pdf_document = get_object_or_404(QualityPDFDocument, id=pdf_id)

    # Create a new ViewingRecord for the user (clock_number)
    ViewingRecord.objects.create(
        operator_number=clock_number,
        pdf_document=pdf_document
    )

    # Fetch the part number from the GET parameter
    part_number = request.GET.get(&#39;part_number&#39;)

    if not part_number:
        # Fall back to the first associated part if not provided
        part_number = pdf_document.associated_parts.first().part_number

    # Retrieve the full list of clock numbers from the GET parameter, falling back to the current clock number if necessary
    clock_numbers = request.GET.get(&#39;clock_numbers&#39;, clock_number)  # Comma-separated list of all clock numbers

    # Redirect back to the PDFs to view page with all clock numbers included in the URL
    return redirect(&#39;pdfs_to_view&#39;, part_number=part_number, clock_numbers=clock_numbers)</code></pre>
</details>
<div class="desc"><p>Record that a user (identified by clock_number) has viewed a PDF and redirect back to the review list.</p>
<h2 id="expects">Expects</h2>
<ul>
<li><code>pdf_id</code> (int):
The primary key of the QualityPDFDocument to mark as viewed.</li>
<li><code>clock_number</code> (str): The operator’s clock number performing the view action.</li>
<li>Optional GET parameters:
• <code>part_number</code> (str): Comma-separated Part identifier to maintain context.
• <code>clock_numbers</code> (str): Comma-separated list of all clock numbers in the session.</li>
</ul>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Retrieve the QualityPDFDocument by <code>pdf_id</code> or return 404.</li>
<li>Create a new ViewingRecord linking <code>operator_number</code> and the PDF.</li>
<li>Determine <code>part_number</code> from GET or fall back to the document’s first associated part.</li>
<li>Determine the full <code>clock_numbers</code> list from GET or default to the current <code>clock_number</code>.</li>
<li>Redirect to <code><a title="quality.views.pdfs_to_view" href="#quality.views.pdfs_to_view">pdfs_to_view()</a></code> with <code>part_number</code> and <code>clock_numbers</code> to continue the review process.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request.</dd>
<dt><strong><code>pdf_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the PDF document being marked viewed.</dd>
<dt><strong><code>clock_number</code></strong> :&ensp;<code>str</code></dt>
<dd>Operator’s clock number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponseRedirect</code></dt>
<dd>Redirects to the <code><a title="quality.views.pdfs_to_view" href="#quality.views.pdfs_to_view">pdfs_to_view()</a></code> view with the appropriate query parameters.</dd>
</dl></div>
</dd>
<dt id="quality.views.new_manager"><code class="name flex">
<span>def <span class="ident">new_manager</span></span>(<span>request, part_number=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@login_required(login_url=&#34;login&#34;)
def new_manager(request, part_number=None):
    &#34;&#34;&#34;
    Display and allow editing of a custom message for a given part, restricted to logged-in users.

    - Access Control:
        • Requires authentication; unauthenticated users are redirected to &#34;login&#34;.
    - Parameter Handling:
        • If `part_number` is None, immediately redirect to the &#39;forms_page&#39; view.
    - Data Retrieval:
        • Fetch the Part identified by `part_number` (404 if not found).
        • Retrieve all associated Feat records.
        • Get or create a PartMessage record for this Part, providing `message` and `font_size` fields.
    - GET:
        • Render the &#39;quality/new_manager.html&#39; template with context:
            - `part`: the Part instance
            - `feats`: its Feat queryset
            - `current_message`: the existing PartMessage.message
            - `current_font_size`: the existing PartMessage.font_size
            - `font_size_choices`: available font size options
    - POST:
        • Read `custom_message` and `font_size` from form data.
        • Update and save the PartMessage record.
        • Reflect changes in context for re-rendering.
    - Debug:
        • Prints initial and updated message/font_size to the console for troubleshooting.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, may be GET or POST.
    part_number : str or None
        The identifier for the Part to manage; if None, redirects to forms selection.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On missing `part_number`: redirect to &#39;forms_page&#39;.
        - Otherwise: renders the management template with the PartMessage context.
    &#34;&#34;&#34;
    if part_number is None:
        return redirect(&#39;forms_page&#39;)
    
    part = get_object_or_404(Part, part_number=part_number)
    feats = part.feat_set.all()

    # Get or create the PartMessage for this part
    part_message, created = PartMessage.objects.get_or_create(part=part)
    current_message = part_message.message
    current_font_size = part_message.font_size

    # Debug output: Initial state
    print(f&#34;Initial PartMessage: message=&#39;{current_message}&#39;, font_size=&#39;{current_font_size}&#39;&#34;)

    if request.method == &#39;POST&#39;:
        # Handle the message and font size update submission
        new_message = request.POST.get(&#39;custom_message&#39;, &#39;&#39;).strip()
        new_font_size = request.POST.get(&#39;font_size&#39;, &#39;medium&#39;)
        print(f&#34;Received from form: new_message=&#39;{new_message}&#39;, new_font_size=&#39;{new_font_size}&#39;&#34;)

        # Save the updated message and font size
        part_message.message = new_message
        part_message.font_size = new_font_size
        part_message.save()

        # Update the debug state
        current_message = new_message
        current_font_size = new_font_size
        print(f&#34;Updated PartMessage: message=&#39;{current_message}&#39;, font_size=&#39;{current_font_size}&#39;&#34;)

    return render(request, &#39;quality/new_manager.html&#39;, {
        &#39;part&#39;: part,
        &#39;feats&#39;: feats,
        &#39;current_message&#39;: current_message,
        &#39;current_font_size&#39;: current_font_size,
        &#39;font_size_choices&#39;: PartMessage.FONT_SIZE_CHOICES,
    })</code></pre>
</details>
<div class="desc"><p>Display and allow editing of a custom message for a given part, restricted to logged-in users.</p>
<ul>
<li>Access Control:
• Requires authentication; unauthenticated users are redirected to "login".</li>
<li>Parameter Handling:
• If <code>part_number</code> is None, immediately redirect to the 'forms_page' view.</li>
<li>Data Retrieval:
• Fetch the Part identified by <code>part_number</code> (404 if not found).
• Retrieve all associated Feat records.
• Get or create a PartMessage record for this Part, providing <code>message</code> and <code>font_size</code> fields.</li>
<li>GET:
• Render the 'quality/new_manager.html' template with context:
- <code>part</code>: the Part instance
- <code>feats</code>: its Feat queryset
- <code>current_message</code>: the existing PartMessage.message
- <code>current_font_size</code>: the existing PartMessage.font_size
- <code>font_size_choices</code>: available font size options</li>
<li>POST:
• Read <code>custom_message</code> and <code>font_size</code> from form data.
• Update and save the PartMessage record.
• Reflect changes in context for re-rendering.</li>
<li>Debug:
• Prints initial and updated message/font_size to the console for troubleshooting.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, may be GET or POST.</dd>
<dt><strong><code>part_number</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>The identifier for the Part to manage; if None, redirects to forms selection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On missing <code>part_number</code>: redirect to 'forms_page'.</li>
<li>Otherwise: renders the management template with the PartMessage context.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.pdf_delete"><code class="name flex">
<span>def <span class="ident">pdf_delete</span></span>(<span>request, pdf_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf_delete(request, pdf_id):
    &#34;&#34;&#34;
    Confirm and delete a PDF document from the quality library.

    - GET:
        • Retrieve the QualityPDFDocument by `pdf_id` (404 if not found).
        • Render &#39;quality/pdf_confirm_delete.html&#39; with context:
            - `pdf_document`: the document pending deletion.

    - POST:
        • Delete the retrieved QualityPDFDocument.
        • Redirect to the &#39;pdf_list&#39; view on success.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, which may be GET or POST.
    pdf_id : int
        The primary key of the QualityPDFDocument to delete.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET: renders &#39;quality/pdf_confirm_delete.html&#39; with `pdf_document`.
        - On POST: redirects to &#39;pdf_list&#39; after deletion.
    &#34;&#34;&#34;
    pdf_document = get_object_or_404(QualityPDFDocument, id=pdf_id)
    if request.method == &#39;POST&#39;:
        pdf_document.delete()
        return redirect(&#39;pdf_list&#39;)
    return render(request, &#39;quality/pdf_confirm_delete.html&#39;, {&#39;pdf_document&#39;: pdf_document})</code></pre>
</details>
<div class="desc"><p>Confirm and delete a PDF document from the quality library.</p>
<ul>
<li>
<p>GET:
• Retrieve the QualityPDFDocument by <code>pdf_id</code> (404 if not found).
• Render 'quality/pdf_confirm_delete.html' with context:
- <code>pdf_document</code>: the document pending deletion.</p>
</li>
<li>
<p>POST:
• Delete the retrieved QualityPDFDocument.
• Redirect to the 'pdf_list' view on success.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, which may be GET or POST.</dd>
<dt><strong><code>pdf_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the QualityPDFDocument to delete.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET: renders 'quality/pdf_confirm_delete.html' with <code>pdf_document</code>.</li>
<li>On POST: redirects to 'pdf_list' after deletion.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.pdf_edit"><code class="name flex">
<span>def <span class="ident">pdf_edit</span></span>(<span>request, pdf_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf_edit(request, pdf_id):
    &#34;&#34;&#34;
    Display and process the PDF edit form for an existing document.

    - GET:
        • Retrieve the QualityPDFDocument by `pdf_id` (404 if not found).
        • Instantiate PDFUploadForm with the existing instance.
        • Render &#39;quality/pdf_edit.html&#39; with context:
            - `form`: the bound form for editing.
            - `pdf_document`: the document being edited.

    - POST:
        • Bind PDFUploadForm with `request.POST`, `request.FILES`, and the existing instance.
        • If valid, save changes to the document (including file and category).
        • Redirect to the &#39;pdf_list&#39; view on success.
        • If invalid, re-render the form with validation errors.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, which may be GET or POST with form data and file uploads.
    pdf_id : int
        The primary key of the QualityPDFDocument to edit.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or invalid POST: renders &#39;quality/pdf_edit.html&#39; with `form` and `pdf_document`.
        - On successful POST: redirects to the &#39;pdf_list&#39; page.
    &#34;&#34;&#34;
    pdf_document = get_object_or_404(QualityPDFDocument, id=pdf_id)
    
    if request.method == &#39;POST&#39;:
        form = PDFUploadForm(request.POST, request.FILES, instance=pdf_document)
        if form.is_valid():
            form.save()
            return redirect(&#39;pdf_list&#39;)
    else:
        form = PDFUploadForm(instance=pdf_document)
    
    return render(request, &#39;quality/pdf_edit.html&#39;, {&#39;form&#39;: form, &#39;pdf_document&#39;: pdf_document})</code></pre>
</details>
<div class="desc"><p>Display and process the PDF edit form for an existing document.</p>
<ul>
<li>
<p>GET:
• Retrieve the QualityPDFDocument by <code>pdf_id</code> (404 if not found).
• Instantiate PDFUploadForm with the existing instance.
• Render 'quality/pdf_edit.html' with context:
- <code>form</code>: the bound form for editing.
- <code>pdf_document</code>: the document being edited.</p>
</li>
<li>
<p>POST:
• Bind PDFUploadForm with <code>request.POST</code>, <code>request.FILES</code>, and the existing instance.
• If valid, save changes to the document (including file and category).
• Redirect to the 'pdf_list' view on success.
• If invalid, re-render the form with validation errors.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, which may be GET or POST with form data and file uploads.</dd>
<dt><strong><code>pdf_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The primary key of the QualityPDFDocument to edit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or invalid POST: renders 'quality/pdf_edit.html' with <code>form</code> and <code>pdf_document</code>.</li>
<li>On successful POST: redirects to the 'pdf_list' page.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.pdf_list"><code class="name flex">
<span>def <span class="ident">pdf_list</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@login_required(login_url=&#34;login&#34;)
def pdf_list(request):
    pdfs = QualityPDFDocument.objects.all()
    return render(request, &#39;quality/pdf_list.html&#39;, {&#39;pdfs&#39;: pdfs})</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="quality.views.pdf_part_clock_form"><code class="name flex">
<span>def <span class="ident">pdf_part_clock_form</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf_part_clock_form(request):
    &#34;&#34;&#34;
    Display and process the part-clock PDF selection form.

    - GET:
        • Retrieve all Part instances.
        • If `part_number` is provided as a query parameter:
            - Fetch the corresponding Part (404 if not found).
            - Load its custom message and font size from PartMessage,
              converting newlines to HTML line breaks.
            - If no PartMessage exists, provide a default notice.
        • Render &#39;quality/pdf_part_clock_form.html&#39; with context:
            - `parts`: QuerySet of all Part objects.
            - `selected_part`: the part_number string (or None).
            - `part_message`: HTML-safe message for display.
            - `font_size`: the chosen font size for the message.

    - POST:
        • Read `selected_part` and the list `clock_numbers[]` from form data.
        • If both are present and non-empty, redirect to the `pdfs_to_view`
          view, passing `part_number` and a comma-separated `clock_numbers`.

    Debug:
      • Prints selected part and submitted clock numbers for troubleshooting.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, which may be GET or POST.
        - GET may include `part_number` in query parameters.
        - POST includes `selected_part` and `clock_numbers[]`.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or incomplete POST: renders the form template with context.
        - On valid POST: redirects to &#39;pdfs_to_view&#39; with appropriate args.
    &#34;&#34;&#34;
    # Get the part_number from query parameters
    part_number = request.GET.get(&#39;part_number&#39;, None)
    parts = Part.objects.all()
    part_message = None
    font_size = &#39;medium&#39;  # Default font size

    if part_number:
        # Retrieve the selected part
        selected_part = get_object_or_404(Part, part_number=part_number)
        
        # Debug output: Selected part
        print(f&#34;Selected part: {selected_part.part_number}&#34;)

        # Retrieve the custom message for the selected part
        try:
            part_message = selected_part.custom_message.message
            font_size = selected_part.custom_message.font_size
            # Convert newlines to HTML line breaks
            part_message = linebreaks(part_message)

            # Debug output: Message and font size
            print(f&#34;Retrieved PartMessage: message=&#39;{part_message}&#39;, font_size=&#39;{font_size}&#39;&#34;)
        except PartMessage.DoesNotExist:
            part_message = &#34;No message available for this part.&#34;
            print(&#34;No PartMessage found for the selected part.&#34;)
    else:
        selected_part = None

    # Pass the part and its message to the context
    context = {
        &#39;parts&#39;: parts,
        &#39;selected_part&#39;: part_number,
        &#39;part_message&#39;: part_message,
        &#39;font_size&#39;: font_size,
    }

    if request.method == &#39;POST&#39;:
        selected_part = request.POST.get(&#39;selected_part&#39;)
        clock_numbers = request.POST.getlist(&#39;clock_numbers[]&#39;)  # Get all clock numbers as a list

        if selected_part and clock_numbers:
            # Redirect to the pdfs_to_view view with the clock numbers
            clock_numbers_list = [num.strip() for num in clock_numbers if num.strip()]
            print(f&#34;Submitted clock_numbers: {clock_numbers_list}&#34;)
            return redirect(&#39;pdfs_to_view&#39;, part_number=selected_part, clock_numbers=&#39;,&#39;.join(clock_numbers_list))

    return render(request, &#39;quality/pdf_part_clock_form.html&#39;, context)</code></pre>
</details>
<div class="desc"><p>Display and process the part-clock PDF selection form.</p>
<ul>
<li>
<p>GET:
• Retrieve all Part instances.
• If <code>part_number</code> is provided as a query parameter:
- Fetch the corresponding Part (404 if not found).
- Load its custom message and font size from PartMessage,
converting newlines to HTML line breaks.
- If no PartMessage exists, provide a default notice.
• Render 'quality/pdf_part_clock_form.html' with context:
- <code>parts</code>: QuerySet of all Part objects.
- <code>selected_part</code>: the part_number string (or None).
- <code>part_message</code>: HTML-safe message for display.
- <code>font_size</code>: the chosen font size for the message.</p>
</li>
<li>
<p>POST:
• Read <code>selected_part</code> and the list <code>clock_numbers[]</code> from form data.
• If both are present and non-empty, redirect to the <code><a title="quality.views.pdfs_to_view" href="#quality.views.pdfs_to_view">pdfs_to_view()</a></code>
view, passing <code>part_number</code> and a comma-separated <code>clock_numbers</code>.</p>
</li>
</ul>
<h2 id="debug">Debug</h2>
<p>• Prints selected part and submitted clock numbers for troubleshooting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, which may be GET or POST.
- GET may include <code>part_number</code> in query parameters.
- POST includes <code>selected_part</code> and <code>clock_numbers[]</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or incomplete POST: renders the form template with context.</li>
<li>On valid POST: redirects to 'pdfs_to_view' with appropriate args.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.pdf_upload"><code class="name flex">
<span>def <span class="ident">pdf_upload</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf_upload(request):
    &#34;&#34;&#34;
    Display and process a PDF upload form.

    - GET:
        • Instantiate an empty PDFUploadForm.
        • Render the &#39;quality/pdf_upload.html&#39; template with `form` context.

    - POST:
        • Bind PDFUploadForm with `request.POST` and `request.FILES`.
        • If valid, save the uploaded PDF (including its `category` field).
        • Redirect to the &#39;pdf_list&#39; view on success.
        • If invalid, fall through to re-render the form with errors.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, which may carry form data and file uploads.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or invalid POST: renders &#39;quality/pdf_upload.html&#39; with `form`.
        - On successful POST: redirects to the &#39;pdf_list&#39; page.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        form = PDFUploadForm(request.POST, request.FILES)
        if form.is_valid():
            form.save()  # This will save the PDF document including the &#39;category&#39; field
            return redirect(&#39;pdf_list&#39;)
    else:
        form = PDFUploadForm()
    return render(request, &#39;quality/pdf_upload.html&#39;, {&#39;form&#39;: form})</code></pre>
</details>
<div class="desc"><p>Display and process a PDF upload form.</p>
<ul>
<li>
<p>GET:
• Instantiate an empty PDFUploadForm.
• Render the 'quality/pdf_upload.html' template with <code>form</code> context.</p>
</li>
<li>
<p>POST:
• Bind PDFUploadForm with <code>request.POST</code> and <code>request.FILES</code>.
• If valid, save the uploaded PDF (including its <code>category</code> field).
• Redirect to the 'pdf_list' view on success.
• If invalid, fall through to re-render the form with errors.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, which may carry form data and file uploads.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or invalid POST: renders 'quality/pdf_upload.html' with <code>form</code>.</li>
<li>On successful POST: redirects to the 'pdf_list' page.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.pdfs_by_part_number"><code class="name flex">
<span>def <span class="ident">pdfs_by_part_number</span></span>(<span>request, part_number)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdfs_by_part_number(request, part_number):
    &#34;&#34;&#34;
    Display all PDF documents for a specific part, grouped by category.

    Retrieves the Part identified by `part_number` (404 if not found),
    fetches all related QualityPDFDocument instances, and organizes them
    into a list of tuples where each tuple contains:
      - category display name (str)
      - QuerySet of PDFs in that category

    Renders &#39;quality/pdfs_by_part_number.html&#39; with context:
      - `part`: the Part instance
      - `pdfs_by_category`: list of (category_display, pdfs_in_category)

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request.
    part_number : str
        The identifier of the Part whose PDFs are to be displayed.

    Returns
    -------
    django.http.HttpResponse
        The rendered HTML page showing PDFs grouped by category.
    &#34;&#34;&#34;
    part = get_object_or_404(Part, part_number=part_number)
    pdfs = part.pdf_documents.all()

    # Build a list of tuples: (category_display_name, pdfs_in_category)
    pdfs_by_category = []
    for code, display in QualityPDFDocument.CATEGORY_CHOICES:
        pdfs_in_category = pdfs.filter(category=code)
        pdfs_by_category.append((display, pdfs_in_category))

    return render(request, &#39;quality/pdfs_by_part_number.html&#39;, {
        &#39;part&#39;: part,
        &#39;pdfs_by_category&#39;: pdfs_by_category,
    })</code></pre>
</details>
<div class="desc"><p>Display all PDF documents for a specific part, grouped by category.</p>
<p>Retrieves the Part identified by <code>part_number</code> (404 if not found),
fetches all related QualityPDFDocument instances, and organizes them
into a list of tuples where each tuple contains:
- category display name (str)
- QuerySet of PDFs in that category</p>
<p>Renders 'quality/pdfs_by_part_number.html' with context:
- <code>part</code>: the Part instance
- <code>pdfs_by_category</code>: list of (category_display, pdfs_in_category)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request.</dd>
<dt><strong><code>part_number</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifier of the Part whose PDFs are to be displayed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code></dt>
<dd>The rendered HTML page showing PDFs grouped by category.</dd>
</dl></div>
</dd>
<dt id="quality.views.pdfs_to_view"><code class="name flex">
<span>def <span class="ident">pdfs_to_view</span></span>(<span>request, part_number, clock_numbers)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdfs_to_view(request, part_number, clock_numbers):
    &#34;&#34;&#34;
    Display PDFs for a given part that have not yet been viewed by specified operators.

    - Retrieves the Part identified by `part_number` (404 if not found).
    - Parses `clock_numbers`, a comma-separated string of operator clock numbers, into a list.
    - For each clock number:
        • Fetches all PDF documents linked to the Part (`part.pdf_documents.all()`).
        • Retrieves ViewingRecord entries for that operator_number.
        • Excludes already-viewed PDFs to build a queryset of unviewed PDFs.
    - Constructs `clock_pdf_status`, a dict mapping each clock number to its unviewed PDFs.
    - Renders &#39;quality/pdfs_to_view.html&#39; with context:
        - `part`: the Part instance.
        - `clock_pdf_status`: dict of clock_number → QuerySet of unviewed PDFs.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request.
    part_number : str
        The identifier of the Part whose PDFs are to be displayed.
    clock_numbers : str
        A comma-separated string of operator clock numbers (e.g., &#34;123,456,789&#34;).

    Returns
    -------
    django.http.HttpResponse
        The rendered template showing, for each clock number, the PDFs not yet viewed.
    &#34;&#34;&#34;
    part = get_object_or_404(Part, part_number=part_number)
    
    # Split the clock_numbers string into a list
    clock_numbers_list = [num.strip() for num in clock_numbers.split(&#39;,&#39;) if num.strip()]
    
    # Initialize a dictionary to store not viewed PDFs for each clock number
    clock_pdf_status = {}

    for clock_number in clock_numbers_list:
        # Get all PDFs associated with this part
        associated_pdfs = part.pdf_documents.all()

        # Get the viewing records for this user (by clock number)
        viewed_pdfs = ViewingRecord.objects.filter(operator_number=clock_number).values_list(&#39;pdf_document_id&#39;, flat=True)

        # Filter PDFs that the user has not viewed yet
        not_viewed_pdfs = associated_pdfs.exclude(id__in=viewed_pdfs)

        # Add the not viewed PDFs to the dictionary with the clock number as the key
        clock_pdf_status[clock_number] = not_viewed_pdfs

    return render(request, &#39;quality/pdfs_to_view.html&#39;, {
        &#39;part&#39;: part,
        &#39;clock_pdf_status&#39;: clock_pdf_status,  # Pass the dictionary of clock numbers and their unviewed PDFs
    })</code></pre>
</details>
<div class="desc"><p>Display PDFs for a given part that have not yet been viewed by specified operators.</p>
<ul>
<li>Retrieves the Part identified by <code>part_number</code> (404 if not found).</li>
<li>Parses <code>clock_numbers</code>, a comma-separated string of operator clock numbers, into a list.</li>
<li>For each clock number:
• Fetches all PDF documents linked to the Part (<code>part.pdf_documents.all()</code>).
• Retrieves ViewingRecord entries for that operator_number.
• Excludes already-viewed PDFs to build a queryset of unviewed PDFs.</li>
<li>Constructs <code>clock_pdf_status</code>, a dict mapping each clock number to its unviewed PDFs.</li>
<li>Renders 'quality/pdfs_to_view.html' with context:<ul>
<li><code>part</code>: the Part instance.</li>
<li><code>clock_pdf_status</code>: dict of clock_number → QuerySet of unviewed PDFs.</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request.</dd>
<dt><strong><code>part_number</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifier of the Part whose PDFs are to be displayed.</dd>
<dt><strong><code>clock_numbers</code></strong> :&ensp;<code>str</code></dt>
<dd>A comma-separated string of operator clock numbers (e.g., "123,456,789").</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code></dt>
<dd>The rendered template showing, for each clock number, the PDFs not yet viewed.</dd>
</dl></div>
</dd>
<dt id="quality.views.red_rabbits_form"><code class="name flex">
<span>def <span class="ident">red_rabbits_form</span></span>(<span>request, part_number)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def red_rabbits_form(request, part_number):
    &#34;&#34;&#34;
    Display and process the Red Rabbits inspection form for a specific part.

    - GET:
        • Retrieve the Part by `part_number` (404 if not found).
        • Fetch all RedRabbitType instances linked to that Part.
        • Provide today’s date (YYYY-MM-DD) as `today` for default form values.
        • Render &#39;quality/red_rabbits_form.html&#39; with context:
            - `part`: the Part instance
            - `red_rabbit_types`: QuerySet of relevant RedRabbitType objects
            - `today`: string of today&#39;s date

    - POST:
        • Read shared fields: `date`, `clock_number`, and `shift`; return errors if any are missing.
        • For each RedRabbitType:
            – Read `verification_okay_&lt;id&gt;` (yes/no), `supervisor_comments_&lt;id&gt;`, and `supervisor_id_&lt;id&gt;`.
            – If verification is “No”, require both comments and supervisor ID; collect errors otherwise.
            – Build a RedRabbitsEntry instance for each type when valid.
        • If any validation errors occur, re-render form with combined `error_message`.
        • On successful validation, bulk-create all RedRabbitsEntry objects and redirect to `final_inspection` for this part.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request; GET to display, POST to submit form data.
    part_number : str
        The identifier of the Part under inspection.

    Returns
    -------
    django.http.HttpResponse or django.http.HttpResponseRedirect
        - On GET or validation failure: renders &#39;quality/red_rabbits_form.html&#39; with context.
        - On successful POST: redirects to the `final_inspection` view for the same part.
    &#34;&#34;&#34;
    # Fetch the specific part using part_number
    part = get_object_or_404(Part, part_number=part_number)
    # Get only the Red Rabbit Types associated with this part
    red_rabbit_types = RedRabbitType.objects.filter(part=part)
    # Today&#39;s date
    today = now().strftime(&#39;%Y-%m-%d&#39;)

    if request.method == &#39;POST&#39;:
        # Shared fields
        date = request.POST.get(&#39;date&#39;)
        clock_number = request.POST.get(&#39;clock_number&#39;)
        shift = request.POST.get(&#39;shift&#39;)

        # Validate shared fields
        if not date or not clock_number or not shift:
            return render(request, &#39;quality/red_rabbits_form.html&#39;, {
                &#39;part&#39;: part,
                &#39;red_rabbit_types&#39;: red_rabbit_types,
                &#39;today&#39;: today,
                &#39;error_message&#39;: &#39;Date, Clock Number, and Shift are required.&#39;,
            })

        entries = []
        errors = []

        # Process entries for each Red Rabbit Type
        for rabbit_type in red_rabbit_types:
            verification_okay = request.POST.get(f&#39;verification_okay_{rabbit_type.id}&#39;) == &#39;yes&#39;
            supervisor_comments = request.POST.get(f&#39;supervisor_comments_{rabbit_type.id}&#39;)
            supervisor_id = request.POST.get(f&#39;supervisor_id_{rabbit_type.id}&#39;)

            # Validate fields for each Red Rabbit Type
            if not verification_okay and (not supervisor_comments or not supervisor_id):
                errors.append(f&#39;Supervisor Comments and ID are required for {rabbit_type.name} if Verification is &#34;No&#34;.&#39;)

            # If no errors, prepare the entry
            if not errors:
                entries.append(RedRabbitsEntry(
                    part=part,
                    red_rabbit_type=rabbit_type,
                    date=date,
                    clock_number=clock_number,
                    shift=int(shift),
                    verification_okay=verification_okay,
                    supervisor_comments=supervisor_comments if not verification_okay else None,
                    supervisor_id=supervisor_id if not verification_okay else None
                ))

        # If there are validation errors, show them
        if errors:
            return render(request, &#39;quality/red_rabbits_form.html&#39;, {
                &#39;part&#39;: part,
                &#39;red_rabbit_types&#39;: red_rabbit_types,
                &#39;today&#39;: today,
                &#39;error_message&#39;: &#39; &#39;.join(errors),
            })

        # Save all entries in bulk if no errors
        RedRabbitsEntry.objects.bulk_create(entries)

        return redirect(&#39;final_inspection&#39;, part_number=part_number)

    return render(request, &#39;quality/red_rabbits_form.html&#39;, {
        &#39;part&#39;: part,
        &#39;red_rabbit_types&#39;: red_rabbit_types,
        &#39;today&#39;: today,
    })</code></pre>
</details>
<div class="desc"><p>Display and process the Red Rabbits inspection form for a specific part.</p>
<ul>
<li>
<p>GET:
• Retrieve the Part by <code>part_number</code> (404 if not found).
• Fetch all RedRabbitType instances linked to that Part.
• Provide today’s date (YYYY-MM-DD) as <code>today</code> for default form values.
• Render 'quality/red_rabbits_form.html' with context:
- <code>part</code>: the Part instance
- <code>red_rabbit_types</code>: QuerySet of relevant RedRabbitType objects
- <code>today</code>: string of today's date</p>
</li>
<li>
<p>POST:
• Read shared fields: <code>date</code>, <code>clock_number</code>, and <code>shift</code>; return errors if any are missing.
• For each RedRabbitType:
– Read <code>verification_okay_&lt;id&gt;</code> (yes/no), <code>supervisor_comments_&lt;id&gt;</code>, and <code>supervisor_id_&lt;id&gt;</code>.
– If verification is “No”, require both comments and supervisor ID; collect errors otherwise.
– Build a RedRabbitsEntry instance for each type when valid.
• If any validation errors occur, re-render form with combined <code>error_message</code>.
• On successful validation, bulk-create all RedRabbitsEntry objects and redirect to <code><a title="quality.views.final_inspection" href="#quality.views.final_inspection">final_inspection()</a></code> for this part.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request; GET to display, POST to submit form data.</dd>
<dt><strong><code>part_number</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifier of the Part under inspection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code> or <code>django.http.HttpResponseRedirect</code></dt>
<dd>
<ul>
<li>On GET or validation failure: renders 'quality/red_rabbits_form.html' with context.</li>
<li>On successful POST: redirects to the <code><a title="quality.views.final_inspection" href="#quality.views.final_inspection">final_inspection()</a></code> view for the same part.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.remove_zeros"><code class="name flex">
<span>def <span class="ident">remove_zeros</span></span>(<span>asset_value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_zeros(asset_value):
    &#34;&#34;&#34;
    Removes trailing &#34;.0&#34; from asset values if they exist.
    &#34;&#34;&#34;
    if isinstance(asset_value, str) and asset_value.endswith(&#34;.0&#34;):
        return asset_value[:-2]  # Strip the last two characters (&#34;.0&#34;)
    return asset_value</code></pre>
</details>
<div class="desc"><p>Removes trailing ".0" from asset values if they exist.</p></div>
</dd>
<dt id="quality.views.scrap_form_management"><code class="name flex">
<span>def <span class="ident">scrap_form_management</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrap_form_management(request):
    &#34;&#34;&#34;
    Display scrap form management page listing all parts and their features.

    Retrieves all Part instances (including those without associated Feat records),
    prefetches related `feat_set` for efficiency, and renders the
    &#39;quality/scrap_form_management.html&#39; template with:
      - `parts`: a QuerySet of all Part objects, each with its `feat_set`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The HTTP request object.

    Returns
    -------
    django.http.HttpResponse
        The rendered management page showing parts and their features.
    &#34;&#34;&#34;
    # Get all parts, whether or not they have feats
    parts = Part.objects.all().prefetch_related(&#39;feat_set&#39;)
    return render(request, &#39;quality/scrap_form_management.html&#39;, {&#39;parts&#39;: parts})</code></pre>
</details>
<div class="desc"><p>Display scrap form management page listing all parts and their features.</p>
<p>Retrieves all Part instances (including those without associated Feat records),
prefetches related <code>feat_set</code> for efficiency, and renders the
'quality/scrap_form_management.html' template with:
- <code>parts</code>: a QuerySet of all Part objects, each with its <code>feat_set</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The HTTP request object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.HttpResponse</code></dt>
<dd>The rendered management page showing parts and their features.</dd>
</dl></div>
</dd>
<dt id="quality.views.send_qc1_asset"><code class="name flex">
<span>def <span class="ident">send_qc1_asset</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def send_qc1_asset(request):
    &#34;&#34;&#34;
    Handle JSON-based requests to duplicate an EPV record with a new Asset value.

    Expects a POST request with a JSON body containing:
      - id (int):     The primary key of the existing `quality_epv_assets` record.
      - asset (str):  The new Asset value (without trailing “.0”).

    Workflow:
      1. Parse and validate the JSON payload; return HTTP 400 if `id` or `asset` is missing or JSON is invalid.
      2. Log the incoming `epv_id` and `new_asset` for debugging.
      3. Invoke `add_new_entry_with_asset(epv_id, new_asset)` to:
         • Retrieve the original row’s data.
         • Append “.0” to the provided asset.
         • Insert a new record copying all other fields.
      4. If insertion succeeds, return HTTP 200 with:
         `{&#34;message&#34;: &#34;New entry added&#34;, &#34;new_entry&#34;: &lt;dict&gt;}`.
      5. If insertion fails, return HTTP 500 with `{&#34;error&#34;: &#34;Failed to add new entry&#34;}`.
      6. Non-POST requests return HTTP 405 with `{&#34;error&#34;: &#34;Invalid request method&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be POST with a JSON payload.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success or error, with an appropriate HTTP status code.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        try:
            data = json.loads(request.body)
            epv_id = data.get(&#34;id&#34;)
            new_asset = data.get(&#34;asset&#34;)

            if not epv_id or not new_asset:
                return JsonResponse({&#34;error&#34;: &#34;Missing ID or Asset&#34;}, status=400)

            print(f&#34;Received QC1 ID: {epv_id}, New Asset: {new_asset}&#34;)  # Print to console

            # Call function to insert new entry
            new_entry = add_new_entry_with_asset(epv_id, new_asset)

            if new_entry:
                return JsonResponse({&#34;message&#34;: &#34;New entry added&#34;, &#34;new_entry&#34;: new_entry}, status=200)
            else:
                return JsonResponse({&#34;error&#34;: &#34;Failed to add new entry&#34;}, status=500)

        except json.JSONDecodeError:
            return JsonResponse({&#34;error&#34;: &#34;Invalid JSON&#34;}, status=400)

    return JsonResponse({&#34;error&#34;: &#34;Invalid request method&#34;}, status=405)</code></pre>
</details>
<div class="desc"><p>Handle JSON-based requests to duplicate an EPV record with a new Asset value.</p>
<p>Expects a POST request with a JSON body containing:
- id (int):
The primary key of the existing <code>quality_epv_assets</code> record.
- asset (str):
The new Asset value (without trailing “.0”).</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse and validate the JSON payload; return HTTP 400 if <code>id</code> or <code>asset</code> is missing or JSON is invalid.</li>
<li>Log the incoming <code>epv_id</code> and <code>new_asset</code> for debugging.</li>
<li>Invoke <code><a title="quality.views.add_new_entry_with_asset" href="#quality.views.add_new_entry_with_asset">add_new_entry_with_asset()</a>(epv_id, new_asset)</code> to:
• Retrieve the original row’s data.
• Append “.0” to the provided asset.
• Insert a new record copying all other fields.</li>
<li>If insertion succeeds, return HTTP 200 with:
<code>{"message": "New entry added", "new_entry": &lt;dict&gt;}</code>.</li>
<li>If insertion fails, return HTTP 500 with <code>{"error": "Failed to add new entry"}</code>.</li>
<li>Non-POST requests return HTTP 405 with <code>{"error": "Invalid request method"}</code>.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be POST with a JSON payload.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success or error, with an appropriate HTTP status code.</dd>
</dl></div>
</dd>
<dt id="quality.views.store_supervisor_auth"><code class="name flex">
<span>def <span class="ident">store_supervisor_auth</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def store_supervisor_auth(request):
    &#34;&#34;&#34;
    Store a supervisor’s authorization for a specific part and feature.

    Accepts only POST requests with a JSON body containing:
      - supervisor_id (int):   The primary key of the Supervisor.
      - part_number (str):     The identifier of the Part being authorized.
      - feat_name (str):       The name of the Feat requiring authorization.

    Workflow:
      1. Parse and validate the JSON payload.
      2. Create a new SupervisorAuthorization record with the provided data.
      3. Return a JSON response indicating success.

    Error Handling:
      - On malformed JSON or database errors, returns HTTP 500 with
        `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &lt;error message&gt;}`.
      - For non-POST requests, returns HTTP 400 with
        `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Invalid request method.&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be a POST with a JSON body.

    Returns
    -------
    django.http.JsonResponse
        - On success: `{&#34;status&#34;: &#34;success&#34;, &#34;message&#34;: &#34;Authorization stored successfully!&#34;}` (HTTP 200).
        - On error:   `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &lt;error details&gt;}` with appropriate HTTP status.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        try:
            data = json.loads(request.body)
            SupervisorAuthorization.objects.create(
                supervisor_id=data.get(&#39;supervisor_id&#39;),
                part_number=data.get(&#39;part_number&#39;),
                feat_name=data.get(&#39;feat_name&#39;)
            )
            return JsonResponse({&#39;status&#39;: &#39;success&#39;, &#39;message&#39;: &#39;Authorization stored successfully!&#39;})
        except Exception as e:
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: str(e)}, status=500)
    return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Invalid request method.&#39;}, status=400)</code></pre>
</details>
<div class="desc"><p>Store a supervisor’s authorization for a specific part and feature.</p>
<p>Accepts only POST requests with a JSON body containing:
- supervisor_id (int):
The primary key of the Supervisor.
- part_number (str):
The identifier of the Part being authorized.
- feat_name (str):
The name of the Feat requiring authorization.</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse and validate the JSON payload.</li>
<li>Create a new SupervisorAuthorization record with the provided data.</li>
<li>Return a JSON response indicating success.</li>
</ol>
<p>Error Handling:
- On malformed JSON or database errors, returns HTTP 500 with
<code>{"status": "error", "message": &lt;error message&gt;}</code>.
- For non-POST requests, returns HTTP 400 with
<code>{"status": "error", "message": "Invalid request method."}</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be a POST with a JSON body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>
<ul>
<li>On success: <code>{"status": "success", "message": "Authorization stored successfully!"}</code> (HTTP 200).</li>
<li>On error:
<code>{"status": "error", "message": &lt;error details&gt;}</code> with appropriate HTTP status.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.submit_scrap_form"><code class="name flex">
<span>def <span class="ident">submit_scrap_form</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def submit_scrap_form(request):
    &#34;&#34;&#34;
    Accept and process a JSON-based scrap form submission, then create related records.

    Only POST requests are supported. Expects a JSON payload containing at least:
      - partNumber (str)
      - date (str or date; will be passed directly to the ScrapForm.date field)
      - operator (str)
      - shift (int or str)
      - qtyPacked (int)
      - totalDefects (int)
      - totalInspected (int)
      - comments (str)
      - detailOther (str)
      - tpcNumber (str)
      - feats (list of dicts), each with:
          • featName (str)
          • defects (int)

    Workflow:
      1. Parse the JSON body.
      2. Create a new `ScrapForm` instance, storing the entire payload in its `payload` field.
      3. For each entry in `feats`, create a `FeatEntry` linked to the new ScrapForm.
      4. Respond with a JSON object:
         `{ &#34;status&#34;: &#34;success&#34;, &#34;redirect_url&#34;: &#34;/quality/pdf/part_clock/?part_number=&lt;partNumber&gt;&#34; }`

    Error Handling:
      - Non-POST requests yield HTTP 400 with `{ &#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Invalid request method.&#34; }`.
      - Malformed JSON or missing required keys will raise a Python exception (uncaught),
        resulting in a 500 error.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be a POST with a JSON payload.

    Returns
    -------
    django.http.JsonResponse
        On success: `{&#34;status&#34;: &#34;success&#34;, &#34;redirect_url&#34;: &lt;url&gt;}` (HTTP 200).
        On invalid method: `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Invalid request method.&#34;}` (HTTP 400).
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        # Load the JSON payload from the request body
        payload = json.loads(request.body)

        # Save the main ScrapForm data
        scrap_form = ScrapForm.objects.create(
            partNumber=payload.get(&#39;partNumber&#39;, &#39;&#39;),
            date=payload.get(&#39;date&#39;, None),
            operator=payload.get(&#39;operator&#39;, &#39;&#39;),
            shift=payload.get(&#39;shift&#39;, None),
            qtyPacked=payload.get(&#39;qtyPacked&#39;, None),
            totalDefects=payload.get(&#39;totalDefects&#39;, None),
            totalInspected=payload.get(&#39;totalInspected&#39;, None),
            comments=payload.get(&#39;comments&#39;, &#39;&#39;),
            detailOther=payload.get(&#39;detailOther&#39;, &#39;&#39;),
            tpc_number=payload.get(&#39;tpcNumber&#39;, &#39;&#39;),
            payload=payload
        )

        # Save each feat as a FeatEntry
        part_number = payload.get(&#39;partNumber&#39;, &#39;&#39;)
        for feat in payload.get(&#39;feats&#39;, []):
            FeatEntry.objects.create(
                scrap_form=scrap_form,
                featName=feat.get(&#39;featName&#39;, &#39;&#39;),
                defects=int(feat.get(&#39;defects&#39;, 0)),
                partNumber=part_number
            )

        # Redirect to pdf_part_clock_form with part number in context
        return JsonResponse({&#39;status&#39;: &#39;success&#39;, &#39;redirect_url&#39;: f&#39;/quality/pdf/part_clock/?part_number={part_number}&#39;})

    return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Invalid request method.&#39;}, status=400)</code></pre>
</details>
<div class="desc"><p>Accept and process a JSON-based scrap form submission, then create related records.</p>
<p>Only POST requests are supported. Expects a JSON payload containing at least:
- partNumber (str)
- date (str or date; will be passed directly to the ScrapForm.date field)
- operator (str)
- shift (int or str)
- qtyPacked (int)
- totalDefects (int)
- totalInspected (int)
- comments (str)
- detailOther (str)
- tpcNumber (str)
- feats (list of dicts), each with:
• featName (str)
• defects (int)</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse the JSON body.</li>
<li>Create a new <code>ScrapForm</code> instance, storing the entire payload in its <code>payload</code> field.</li>
<li>For each entry in <code>feats</code>, create a <code>FeatEntry</code> linked to the new ScrapForm.</li>
<li>Respond with a JSON object:
<code>{ "status": "success", "redirect_url": "/quality/pdf/part_clock/?part_number=&lt;partNumber&gt;" }</code></li>
</ol>
<p>Error Handling:
- Non-POST requests yield HTTP 400 with <code>{ "status": "error", "message": "Invalid request method." }</code>.
- Malformed JSON or missing required keys will raise a Python exception (uncaught),
resulting in a 500 error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be a POST with a JSON payload.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>On success: <code>{"status": "success", "redirect_url": &lt;url&gt;}</code> (HTTP 200).
On invalid method: <code>{"status": "error", "message": "Invalid request method."}</code> (HTTP 400).</dd>
</dl></div>
</dd>
<dt id="quality.views.update_asset"><code class="name flex">
<span>def <span class="ident">update_asset</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def update_asset(request):
    &#34;&#34;&#34;
    Update the Asset field of an EPV record via JSON POST.

    Expects a POST request with a JSON body containing:
      - id (int):    The primary key of the `quality_epv_assets` record to update.
      - asset (str): The new asset value (without trailing “.0”).

    Workflow:
      1. Parse and validate the JSON payload; return HTTP 400 if `id` or `asset` is missing.
      2. Append “.0” to the provided `asset` value.
      3. Establish a MySQL connection via `get_creds()`; return HTTP 500 on connection error.
      4. Execute an UPDATE statement on `quality_epv_assets` to set `Asset = %s` for the given `id`.
      5. Commit the transaction and close the connection.
      6. Return HTTP 200 with `{&#34;message&#34;: &#34;Asset updated successfully&#34;}` on success.

    Error Handling:
      - Missing `id` or `asset`: HTTP 400 with `{&#34;error&#34;: &#34;Missing ID or Asset&#34;}`.
      - JSON decode error: HTTP 400 with `{&#34;error&#34;: &#34;Invalid JSON&#34;}`.
      - Database errors: HTTP 500 with `{&#34;error&#34;: &#34;Database error: &lt;details&gt;&#34;}`.
      - Non-POST requests: HTTP 405 with `{&#34;error&#34;: &#34;Invalid request method&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be POST with a JSON body.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success or error with an appropriate HTTP status.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        try:
            data = json.loads(request.body)
            epv_id = data.get(&#34;id&#34;)
            new_asset = data.get(&#34;asset&#34;)

            if not epv_id or not new_asset:
                return JsonResponse({&#34;error&#34;: &#34;Missing ID or Asset&#34;}, status=400)

            # Append .0 to the asset value
            new_asset = add_zeros(new_asset)

            connection = get_creds()
            if connection.is_connected():
                cursor = connection.cursor()
                update_query = &#34;UPDATE quality_epv_assets SET Asset = %s WHERE id = %s&#34;
                cursor.execute(update_query, (new_asset, epv_id))
                connection.commit()
                cursor.close()
                connection.close()
                return JsonResponse({&#34;message&#34;: &#34;Asset updated successfully&#34;}, status=200)

        except Error as e:
            return JsonResponse({&#34;error&#34;: f&#34;Database error: {e}&#34;}, status=500)
        except json.JSONDecodeError:
            return JsonResponse({&#34;error&#34;: &#34;Invalid JSON&#34;}, status=400)

    return JsonResponse({&#34;error&#34;: &#34;Invalid request method&#34;}, status=405)</code></pre>
</details>
<div class="desc"><p>Update the Asset field of an EPV record via JSON POST.</p>
<p>Expects a POST request with a JSON body containing:
- id (int):
The primary key of the <code>quality_epv_assets</code> record to update.
- asset (str): The new asset value (without trailing “.0”).</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse and validate the JSON payload; return HTTP 400 if <code>id</code> or <code>asset</code> is missing.</li>
<li>Append “.0” to the provided <code>asset</code> value.</li>
<li>Establish a MySQL connection via <code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds()</a></code>; return HTTP 500 on connection error.</li>
<li>Execute an UPDATE statement on <code>quality_epv_assets</code> to set <code>Asset = %s</code> for the given <code>id</code>.</li>
<li>Commit the transaction and close the connection.</li>
<li>Return HTTP 200 with <code>{"message": "Asset updated successfully"}</code> on success.</li>
</ol>
<p>Error Handling:
- Missing <code>id</code> or <code>asset</code>: HTTP 400 with <code>{"error": "Missing ID or Asset"}</code>.
- JSON decode error: HTTP 400 with <code>{"error": "Invalid JSON"}</code>.
- Database errors: HTTP 500 with <code>{"error": "Database error: &lt;details&gt;"}</code>.
- Non-POST requests: HTTP 405 with <code>{"error": "Invalid request method"}</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be POST with a JSON body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success or error with an appropriate HTTP status.</dd>
</dl></div>
</dd>
<dt id="quality.views.update_feat"><code class="name flex">
<span>def <span class="ident">update_feat</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def update_feat(request):
    &#34;&#34;&#34;
    Update fields of an existing Feat via JSON payload.

    Expects a POST request with a JSON body containing:
      - id (int):         The primary key of the Feat to update.
      - name (str):       The new name for the Feat.
      - alarm (any):      The new alarm value for the Feat.
      - critical (bool):  Whether the Feat is critical (defaults to False if omitted).

    Workflow:
      1. Parse the JSON payload.
      2. Retrieve the Feat instance by `id` (return error if not found).
      3. Update `name`, `alarm`, and `critical` fields.
      4. Save the Feat and return `{&#34;status&#34;: &#34;success&#34;}`.
      5. On errors, return a JSON response with `status: &#34;error&#34;` and an error message.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be POST with JSON body.

    Returns
    -------
    django.http.JsonResponse
        - On success: `{&#34;status&#34;: &#34;success&#34;}` (HTTP 200).
        - On missing Feat: `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Feat not found.&#34;}` (HTTP 200).
        - On other errors: `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &lt;error&gt;}` (HTTP 200).
        - On invalid method: `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Invalid request method.&#34;}` (HTTP 400).
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        data = json.loads(request.body)
        feat_id = data.get(&#39;id&#39;)
        new_name = data.get(&#39;name&#39;)
        new_alarm = data.get(&#39;alarm&#39;)
        new_critical = data.get(&#39;critical&#39;, False)  # Get the critical field, defaulting to False

        try:
            feat = Feat.objects.get(id=feat_id)
            feat.name = new_name
            feat.alarm = new_alarm
            feat.critical = new_critical  # Update the critical field
            feat.save()

            return JsonResponse({&#39;status&#39;: &#39;success&#39;})
        except Feat.DoesNotExist:
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Feat not found.&#39;})
        except Exception as e:
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: str(e)})

    return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Invalid request method.&#39;}, status=400)</code></pre>
</details>
<div class="desc"><p>Update fields of an existing Feat via JSON payload.</p>
<p>Expects a POST request with a JSON body containing:
- id (int):
The primary key of the Feat to update.
- name (str):
The new name for the Feat.
- alarm (any):
The new alarm value for the Feat.
- critical (bool):
Whether the Feat is critical (defaults to False if omitted).</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse the JSON payload.</li>
<li>Retrieve the Feat instance by <code>id</code> (return error if not found).</li>
<li>Update <code>name</code>, <code>alarm</code>, and <code>critical</code> fields.</li>
<li>Save the Feat and return <code>{"status": "success"}</code>.</li>
<li>On errors, return a JSON response with <code>status: "error"</code> and an error message.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be POST with JSON body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>
<ul>
<li>On success: <code>{"status": "success"}</code> (HTTP 200).</li>
<li>On missing Feat: <code>{"status": "error", "message": "Feat not found."}</code> (HTTP 200).</li>
<li>On other errors: <code>{"status": "error", "message": &lt;error&gt;}</code> (HTTP 200).</li>
<li>On invalid method: <code>{"status": "error", "message": "Invalid request method."}</code> (HTTP 400).</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="quality.views.update_feat_order"><code class="name flex">
<span>def <span class="ident">update_feat_order</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def update_feat_order(request):
    &#34;&#34;&#34;
    Bulk-update the display order of Feat records via a JSON payload.

    Expects a POST request with a JSON array in the body, where each element
    is an object containing:
      - id (int):    The primary key of the Feat to update.
      - order (int): The new order value for that Feat.

    Workflow:
      1. Parse the JSON body into `order_data`.
      2. Open an atomic transaction.
      3. For each item in the array, update the corresponding Feat’s `order`.
      4. If all updates succeed, return `{&#34;status&#34;: &#34;success&#34;}`.
      5. If any error occurs during updates, roll back and return
         `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &lt;error&gt;}`.

    Error Handling:
      - Non-POST requests return HTTP 400 with
        `{&#34;status&#34;: &#34;error&#34;, &#34;message&#34;: &#34;Invalid request method.&#34;}`.
      - JSON parsing or database errors result in a JSON error response
        with the exception message.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be POST with a JSON body.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success or error.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        order_data = json.loads(request.body)

        try:
            with transaction.atomic():
                for item in order_data:
                    feat_id = item[&#39;id&#39;]
                    new_order = item[&#39;order&#39;]
                    Feat.objects.filter(id=feat_id).update(order=new_order)
            return JsonResponse({&#39;status&#39;: &#39;success&#39;})
        except Exception as e:
            return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: str(e)})

    return JsonResponse({&#39;status&#39;: &#39;error&#39;, &#39;message&#39;: &#39;Invalid request method.&#39;}, status=400)</code></pre>
</details>
<div class="desc"><p>Bulk-update the display order of Feat records via a JSON payload.</p>
<p>Expects a POST request with a JSON array in the body, where each element
is an object containing:
- id (int):
The primary key of the Feat to update.
- order (int): The new order value for that Feat.</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse the JSON body into <code>order_data</code>.</li>
<li>Open an atomic transaction.</li>
<li>For each item in the array, update the corresponding Feat’s <code>order</code>.</li>
<li>If all updates succeed, return <code>{"status": "success"}</code>.</li>
<li>If any error occurs during updates, roll back and return
<code>{"status": "error", "message": &lt;error&gt;}</code>.</li>
</ol>
<p>Error Handling:
- Non-POST requests return HTTP 400 with
<code>{"status": "error", "message": "Invalid request method."}</code>.
- JSON parsing or database errors result in a JSON error response
with the exception message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be POST with a JSON body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success or error.</dd>
</dl></div>
</dd>
<dt id="quality.views.update_person"><code class="name flex">
<span>def <span class="ident">update_person</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def update_person(request):
    &#34;&#34;&#34;
    Update the `Person` field for all EPV asset records sharing the same QC1 value, based on a JSON POST.

    Expects a POST request with a JSON body containing:
      - id (int):     The primary key of the `quality_epv_assets` record whose QC1 will be used.
      - person (str): The new Person name to apply to all records with that QC1.

    Workflow:
      1. Parse and validate the JSON payload; return HTTP 400 if `id` or `person` is missing or JSON is invalid.
      2. Log the incoming `epv_id` and `new_person` for debugging.
      3. Invoke `fetch_related_persons(epv_id, new_person)` to:
         • Retrieve the QC1 value for `epv_id`.
         • Find all rows with that QC1.
         • Bulk-update their `Person` field.
      4. Return HTTP 200 with a success message.

    Error Handling:
      - Missing or empty `id`/`person`: HTTP 400 with `{&#34;error&#34;: &#34;Missing ID or Person&#34;}`.
      - Malformed JSON: HTTP 400 with `{&#34;error&#34;: &#34;Invalid JSON&#34;}`.
      - Non-POST requests: HTTP 405 with `{&#34;error&#34;: &#34;Invalid request method&#34;}`.

    Parameters
    ----------
    request : django.http.HttpRequest
        The incoming HTTP request, expected to be a POST with a JSON payload.

    Returns
    -------
    django.http.JsonResponse
        A JSON response indicating success or error, with the appropriate HTTP status code.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        try:
            data = json.loads(request.body)
            epv_id = data.get(&#34;id&#34;)
            new_person = data.get(&#34;person&#34;)

            if not epv_id or not new_person:
                return JsonResponse({&#34;error&#34;: &#34;Missing ID or Person&#34;}, status=400)

            print(f&#34;EPV ID: {epv_id}, New Person: {new_person}&#34;)

            # Call the function to update related persons
            fetch_related_persons(epv_id, new_person)

            return JsonResponse({&#34;message&#34;: &#34;Person updated for all related entries&#34;}, status=200)

        except json.JSONDecodeError:
            return JsonResponse({&#34;error&#34;: &#34;Invalid JSON&#34;}, status=400)

    return JsonResponse({&#34;error&#34;: &#34;Invalid request method&#34;}, status=405)</code></pre>
</details>
<div class="desc"><p>Update the <code>Person</code> field for all EPV asset records sharing the same QC1 value, based on a JSON POST.</p>
<p>Expects a POST request with a JSON body containing:
- id (int):
The primary key of the <code>quality_epv_assets</code> record whose QC1 will be used.
- person (str): The new Person name to apply to all records with that QC1.</p>
<h2 id="workflow">Workflow</h2>
<ol>
<li>Parse and validate the JSON payload; return HTTP 400 if <code>id</code> or <code>person</code> is missing or JSON is invalid.</li>
<li>Log the incoming <code>epv_id</code> and <code>new_person</code> for debugging.</li>
<li>Invoke <code><a title="quality.views.fetch_related_persons" href="#quality.views.fetch_related_persons">fetch_related_persons()</a>(epv_id, new_person)</code> to:
• Retrieve the QC1 value for <code>epv_id</code>.
• Find all rows with that QC1.
• Bulk-update their <code>Person</code> field.</li>
<li>Return HTTP 200 with a success message.</li>
</ol>
<p>Error Handling:
- Missing or empty <code>id</code>/<code>person</code>: HTTP 400 with <code>{"error": "Missing ID or Person"}</code>.
- Malformed JSON: HTTP 400 with <code>{"error": "Invalid JSON"}</code>.
- Non-POST requests: HTTP 405 with <code>{"error": "Invalid request method"}</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>django.http.HttpRequest</code></dt>
<dd>The incoming HTTP request, expected to be a POST with a JSON payload.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>django.http.JsonResponse</code></dt>
<dd>A JSON response indicating success or error, with the appropriate HTTP status code.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="quality.views.add_feat" href="#quality.views.add_feat">add_feat</a></code></li>
<li><code><a title="quality.views.add_new_entry_with_asset" href="#quality.views.add_new_entry_with_asset">add_new_entry_with_asset</a></code></li>
<li><code><a title="quality.views.add_new_epv" href="#quality.views.add_new_epv">add_new_epv</a></code></li>
<li><code><a title="quality.views.add_zeros" href="#quality.views.add_zeros">add_zeros</a></code></li>
<li><code><a title="quality.views.change_part" href="#quality.views.change_part">change_part</a></code></li>
<li><code><a title="quality.views.delete_epv" href="#quality.views.delete_epv">delete_epv</a></code></li>
<li><code><a title="quality.views.delete_feat" href="#quality.views.delete_feat">delete_feat</a></code></li>
<li><code><a title="quality.views.edit_column" href="#quality.views.edit_column">edit_column</a></code></li>
<li><code><a title="quality.views.edit_related_column_by_qc1" href="#quality.views.edit_related_column_by_qc1">edit_related_column_by_qc1</a></code></li>
<li><code><a title="quality.views.epv_table_view" href="#quality.views.epv_table_view">epv_table_view</a></code></li>
<li><code><a title="quality.views.feat_create" href="#quality.views.feat_create">feat_create</a></code></li>
<li><code><a title="quality.views.feat_delete" href="#quality.views.feat_delete">feat_delete</a></code></li>
<li><code><a title="quality.views.feat_move_down" href="#quality.views.feat_move_down">feat_move_down</a></code></li>
<li><code><a title="quality.views.feat_move_up" href="#quality.views.feat_move_up">feat_move_up</a></code></li>
<li><code><a title="quality.views.feat_update" href="#quality.views.feat_update">feat_update</a></code></li>
<li><code><a title="quality.views.fetch_all_data" href="#quality.views.fetch_all_data">fetch_all_data</a></code></li>
<li><code><a title="quality.views.fetch_related_persons" href="#quality.views.fetch_related_persons">fetch_related_persons</a></code></li>
<li><code><a title="quality.views.final_inspection" href="#quality.views.final_inspection">final_inspection</a></code></li>
<li><code><a title="quality.views.forms_page" href="#quality.views.forms_page">forms_page</a></code></li>
<li><code><a title="quality.views.get_all_data" href="#quality.views.get_all_data">get_all_data</a></code></li>
<li><code><a title="quality.views.get_creds" href="#quality.views.get_creds">get_creds</a></code></li>
<li><code><a title="quality.views.index" href="#quality.views.index">index</a></code></li>
<li><code><a title="quality.views.manage_red_rabbit_types" href="#quality.views.manage_red_rabbit_types">manage_red_rabbit_types</a></code></li>
<li><code><a title="quality.views.mark_pdf_as_viewed" href="#quality.views.mark_pdf_as_viewed">mark_pdf_as_viewed</a></code></li>
<li><code><a title="quality.views.new_manager" href="#quality.views.new_manager">new_manager</a></code></li>
<li><code><a title="quality.views.pdf_delete" href="#quality.views.pdf_delete">pdf_delete</a></code></li>
<li><code><a title="quality.views.pdf_edit" href="#quality.views.pdf_edit">pdf_edit</a></code></li>
<li><code><a title="quality.views.pdf_list" href="#quality.views.pdf_list">pdf_list</a></code></li>
<li><code><a title="quality.views.pdf_part_clock_form" href="#quality.views.pdf_part_clock_form">pdf_part_clock_form</a></code></li>
<li><code><a title="quality.views.pdf_upload" href="#quality.views.pdf_upload">pdf_upload</a></code></li>
<li><code><a title="quality.views.pdfs_by_part_number" href="#quality.views.pdfs_by_part_number">pdfs_by_part_number</a></code></li>
<li><code><a title="quality.views.pdfs_to_view" href="#quality.views.pdfs_to_view">pdfs_to_view</a></code></li>
<li><code><a title="quality.views.red_rabbits_form" href="#quality.views.red_rabbits_form">red_rabbits_form</a></code></li>
<li><code><a title="quality.views.remove_zeros" href="#quality.views.remove_zeros">remove_zeros</a></code></li>
<li><code><a title="quality.views.scrap_form_management" href="#quality.views.scrap_form_management">scrap_form_management</a></code></li>
<li><code><a title="quality.views.send_qc1_asset" href="#quality.views.send_qc1_asset">send_qc1_asset</a></code></li>
<li><code><a title="quality.views.store_supervisor_auth" href="#quality.views.store_supervisor_auth">store_supervisor_auth</a></code></li>
<li><code><a title="quality.views.submit_scrap_form" href="#quality.views.submit_scrap_form">submit_scrap_form</a></code></li>
<li><code><a title="quality.views.update_asset" href="#quality.views.update_asset">update_asset</a></code></li>
<li><code><a title="quality.views.update_feat" href="#quality.views.update_feat">update_feat</a></code></li>
<li><code><a title="quality.views.update_feat_order" href="#quality.views.update_feat_order">update_feat_order</a></code></li>
<li><code><a title="quality.views.update_person" href="#quality.views.update_person">update_person</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
