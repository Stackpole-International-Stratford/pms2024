<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>forms.views API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>forms.views</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="forms.views.bulk_form_and_question_create_view"><code class="name flex">
<span>def <span class="ident">bulk_form_and_question_create_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_form_and_question_create_view(request):
    &#34;&#34;&#34;
    Handle bulk creation of a new &#34;OIS&#34; form together with its questions from JSON input.

    This view accepts POST submissions containing:
      - `data_json`: a JSON string with the form properties under `&#34;form&#34;` 
        and a list of question definitions under `&#34;questions&#34;`.
      - `delete_existing`: an optional checkbox; if checked, any pre-existing 
        questions on the newly created form will be removed before adding the new ones.

    On POST:
      1. Parse `data_json` into a dict, returning an error in the form if parsing fails.
      2. Extract form metadata (part number, operation, machine, etc.) and create 
         a new `Form` instance of type `&#34;OIS&#34;`.
      3. If `delete_existing` is true, delete any existing questions for that form.
      4. Iterate over the provided questions, assign an `order` (defaulting to the 
         index if none provided), and create each `FormQuestion` linked to the form.
      5. Redirect to the form’s edit page on success.

    On GET:
      Renders the bulk-upload template so the user can paste or upload their JSON.

    Args:
        request (django.http.HttpRequest):
            The HTTP request object. On POST, expects `data_json` and optional 
            `delete_existing` in `request.POST`.

    Returns:
        django.http.HttpResponse:
            - On GET: renders `&#34;forms/bulk_question_create.html&#34;`.
            - On POST with invalid JSON: re-renders the same template with an `error` 
              message and the original `data_json` for correction.
            - On successful POST: redirects to the `&#34;form_edit&#34;` view for the new form.

    Raises:
        FormType.DoesNotExist:
            If the `&#34;OIS&#34;` FormType cannot be found in the database.
    &#34;&#34;&#34;
    if request.method == &#39;POST&#39;:
        data_json = request.POST.get(&#39;data_json&#39;)
        delete_existing = request.POST.get(&#39;delete_existing&#39;) == &#39;on&#39;

        try:
            data = json.loads(data_json)
        except json.JSONDecodeError as e:
            return render(request, &#39;forms/bulk_question_create.html&#39;, {
                &#39;error&#39;: f&#39;Invalid JSON data: {e}&#39;,
                &#39;data_json&#39;: data_json,
            })

        form_data = data.get(&#39;form&#39;)
        questions_data = data.get(&#39;questions&#39;, [])

        # Create the new OIS Form
        form_instance = Form(
            name=form_data.get(&#39;name&#39;),
            form_type=FormType.objects.get(name=&#34;OIS&#34;),
            metadata={
                &#39;part_number&#39;: form_data.get(&#39;part_number&#39;),
                &#39;operation&#39;: form_data.get(&#39;operation&#39;),
                &#39;part_name&#39;: form_data.get(&#39;part_name&#39;),
                &#39;year&#39;: form_data.get(&#39;year&#39;),
                &#39;mod_level&#39;: form_data.get(&#39;mod_level&#39;),
                &#39;machine&#39;: form_data.get(&#39;machine&#39;),
                &#39;mod_date&#39;: form_data.get(&#39;mod_date&#39;)
            }
        )
        form_instance.save()

        # Optionally delete existing questions if specified
        if delete_existing:
            form_instance.questions.all().delete()

        # Create questions associated with this form
        for index, question_data in enumerate(questions_data, start=1):
            question_data[&#39;order&#39;] = question_data.get(&#39;order&#39;, index)
            FormQuestion.objects.create(
                form=form_instance,
                question=question_data
            )

        return redirect(&#39;form_edit&#39;, form_id=form_instance.id)

    else:
        return render(request, &#39;forms/bulk_question_create.html&#39;)</code></pre>
</details>
<div class="desc"><p>Handle bulk creation of a new "OIS" form together with its questions from JSON input.</p>
<p>This view accepts POST submissions containing:
- <code>data_json</code>: a JSON string with the form properties under <code>"form"</code>
and a list of question definitions under <code>"questions"</code>.
- <code>delete_existing</code>: an optional checkbox; if checked, any pre-existing
questions on the newly created form will be removed before adding the new ones.</p>
<p>On POST:
1. Parse <code>data_json</code> into a dict, returning an error in the form if parsing fails.
2. Extract form metadata (part number, operation, machine, etc.) and create
a new <code>Form</code> instance of type <code>"OIS"</code>.
3. If <code>delete_existing</code> is true, delete any existing questions for that form.
4. Iterate over the provided questions, assign an <code>order</code> (defaulting to the
index if none provided), and create each <code>FormQuestion</code> linked to the form.
5. Redirect to the form’s edit page on success.</p>
<p>On GET:
Renders the bulk-upload template so the user can paste or upload their JSON.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The HTTP request object. On POST, expects <code>data_json</code> and optional
<code>delete_existing</code> in <code>request.POST</code>.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
- On GET: renders <code>"forms/bulk_question_create.html"</code>.
- On POST with invalid JSON: re-renders the same template with an <code>error</code>
message and the original <code>data_json</code> for correction.
- On successful POST: redirects to the <code>"form_edit"</code> view for the new form.</p>
<h2 id="raises">Raises</h2>
<p>FormType.DoesNotExist:
If the <code>"OIS"</code> FormType cannot be found in the database.</p></div>
</dd>
<dt id="forms.views.closed_lpas_view"><code class="name flex">
<span>def <span class="ident">closed_lpas_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closed_lpas_view(request):
    &#34;&#34;&#34;
    Display and edit previously closed-out LPA answers.

    On POST:
      1. Retrieves `answer_id`, `closeout_notes`, and `closeout_date` from the submitted form.
      2. Validates `closeout_date` in YYYY-MM-DD format.
      3. If valid, updates the corresponding `FormAnswer` JSON `answer` field with the new
         `closeout_date` and `closeout_notes`, then saves.
      4. Redirects back to the same view to refresh the listing. Invalid dates simply reload.

    On GET:
      1. Queries for all `FormAnswer` instances of form type ID 15 where `&#34;closed_out&#34;: True`.
      2. Passes these to `forms/closed_lpas.html` for display and potential editing.

    Args:
        request (django.http.HttpRequest):
            The HTTP request, either GET for listing or POST for editing an existing closeout.

    Returns:
        django.http.HttpResponse:
            - On GET: renders `&#34;forms/closed_lpas.html&#34;` with context `{&#39;closed_answers&#39;: closed_answers}`.
            - On POST: redirects to `&#39;closed_lpas&#39;`, regardless of date validity.
    &#34;&#34;&#34;
    from datetime import datetime
    if request.method == &#39;POST&#39;:
        # Handle editing closeout notes and date
        answer_id = request.POST.get(&#39;answer_id&#39;)
        closeout_notes = request.POST.get(&#39;closeout_notes&#39;, &#39;&#39;)
        closeout_date = request.POST.get(&#39;closeout_date&#39;, &#39;&#39;)

        # Validate closeout_date
        try:
            closeout_date_parsed = datetime.strptime(closeout_date, &#39;%Y-%m-%d&#39;) if closeout_date else None
        except ValueError:
            closeout_date_parsed = None

        if not closeout_date_parsed:
            return redirect(&#39;closed_lpas&#39;)  # Invalid date, refresh for now

        # Fetch the answer and update the JSON field
        try:
            answer = FormAnswer.objects.get(id=answer_id)
            updated_answer = answer.answer.copy()  # Create a copy of the JSON field
            updated_answer[&#39;closeout_date&#39;] = closeout_date_parsed.strftime(&#39;%Y-%m-%d&#39;)
            updated_answer[&#39;closeout_notes&#39;] = closeout_notes
            answer.answer = updated_answer
            answer.save()
        except FormAnswer.DoesNotExist:
            pass  # Handle gracefully if answer is missing

        return redirect(&#39;closed_lpas&#39;)  # Redirect to refresh the page

    # Fetch answers where closed_out = true
    closed_answers = FormAnswer.objects.filter(
        answer__contains={&#39;closed_out&#39;: True},
        question__form__form_type__id=15
    ).select_related(&#39;question__form__form_type&#39;)

    # Debugging output
    print(&#34;DEBUG: Closed LPAs fetched:&#34;)
    for answer in closed_answers:
        print(
            f&#34;Answer ID: {answer.id}, Question ID: {answer.question.id}, &#34;
            f&#34;Closeout Date: {answer.answer.get(&#39;closeout_date&#39;, &#39;N/A&#39;)}, &#34;
            f&#34;Closeout Notes: {answer.answer.get(&#39;closeout_notes&#39;, &#39;N/A&#39;)}, &#34;
            f&#34;Form Name: {answer.question.form.name}&#34;
        )

    context = {
        &#39;closed_answers&#39;: closed_answers
    }
    return render(request, &#39;forms/closed_lpas.html&#39;, context)</code></pre>
</details>
<div class="desc"><p>Display and edit previously closed-out LPA answers.</p>
<p>On POST:
1. Retrieves <code>answer_id</code>, <code>closeout_notes</code>, and <code>closeout_date</code> from the submitted form.
2. Validates <code>closeout_date</code> in YYYY-MM-DD format.
3. If valid, updates the corresponding <code>FormAnswer</code> JSON <code>answer</code> field with the new
<code>closeout_date</code> and <code>closeout_notes</code>, then saves.
4. Redirects back to the same view to refresh the listing. Invalid dates simply reload.</p>
<p>On GET:
1. Queries for all <code>FormAnswer</code> instances of form type ID 15 where <code>"closed_out": True</code>.
2. Passes these to <code>forms/closed_lpas.html</code> for display and potential editing.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The HTTP request, either GET for listing or POST for editing an existing closeout.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
- On GET: renders <code>"forms/closed_lpas.html"</code> with context <code>{'closed_answers': closed_answers}</code>.
- On POST: redirects to <code>'closed_lpas'</code>, regardless of date validity.</p></div>
</dd>
<dt id="forms.views.create_form_copy_view"><code class="name flex">
<span>def <span class="ident">create_form_copy_view</span></span>(<span>request, form_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_form_copy_view(request, form_id):
    &#34;&#34;&#34;
    Create a duplicate of an existing Form (identified by `form_id`) along with all its questions,
    allowing new metadata values for name, part number, and operation.

    On POST:
      1. Validates presence of `name`, `part_number`, and `operation` in `request.POST`.
      2. Creates a new `Form` instance using the original form’s type and metadata,
         overriding only the provided `part_number` and `operation` and setting the new `name`.
      3. Copies each `FormQuestion` from the original form into the new form.
      4. Returns a JSON success message with status 200.

    On other methods:
      - Returns a JSON error with status 405.

    Args:
        request (django.http.HttpRequest):
            The incoming HTTP request. Must be POST to perform the copy.
        form_id (int):
            The primary key of the existing `Form` to duplicate.

    Returns:
        django.http.JsonResponse:
            - On success (POST): `{&#39;message&#39;: &#39;Successfully created a copy of the form: &lt;name&gt;.&#39;}`, status=200.
            - On missing fields: `{&#39;error&#39;: &#39;All fields (name, part_number, operation) are required.&#39;}`, status=400.
            - On original form not found: `{&#39;error&#39;: &#39;Original form not found.&#39;}`, status=404.
            - On creation or copy failure: appropriate `{&#39;error&#39;: &lt;message&gt;}`, status=500.
            - On non-POST requests: `{&#39;error&#39;: &#39;Invalid request method.&#39;}`, status=405.
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    View to create a copy of a form and its questions with new metadata.
    &#34;&#34;&#34;
    print(f&#34;[DEBUG] Entering create_form_copy_view with form_id: {form_id}&#34;)

    # Attempt to retrieve the original form
    try:
        original_form = get_object_or_404(Form, id=form_id)
        print(f&#34;[DEBUG] Original form retrieved: {original_form}&#34;)
    except Exception as e:
        print(f&#34;[ERROR] Could not retrieve original form: {e}&#34;)
        return JsonResponse({&#39;error&#39;: &#39;Original form not found.&#39;}, status=404)

    if request.method == &#39;POST&#39;:
        print(&#34;[DEBUG] Processing POST request&#34;)
        
        # Get new metadata from the request
        name = request.POST.get(&#39;name&#39;)
        part_number = request.POST.get(&#39;part_number&#39;)
        operation = request.POST.get(&#39;operation&#39;)

        print(f&#34;[DEBUG] Received POST data: name={name}, part_number={part_number}, operation={operation}&#34;)

        # Check for missing fields
        if not name or not part_number or not operation:
            print(&#34;[ERROR] Missing required fields in POST data&#34;)
            return JsonResponse({&#39;error&#39;: &#39;All fields (name, part_number, operation) are required.&#39;}, status=400)

        try:
            # Create the new form instance with new metadata
            new_form = Form.objects.create(
                name=name,
                form_type=original_form.form_type,
                metadata={
                    &#39;part_number&#39;: part_number,
                    &#39;operation&#39;: operation,
                    **{k: v for k, v in original_form.metadata.items() if k not in [&#39;part_number&#39;, &#39;operation&#39;]}
                }
            )
            print(f&#34;[DEBUG] New form created: {new_form}&#34;)
        except Exception as e:
            print(f&#34;[ERROR] Failed to create new form: {e}&#34;)
            return JsonResponse({&#39;error&#39;: &#39;Failed to create a new form.&#39;}, status=500)

        try:
            # Copy all questions from the original form to the new form
            for question in original_form.questions.all():
                FormQuestion.objects.create(
                    form=new_form,
                    question=question.question
                )
            print(f&#34;[DEBUG] Questions copied to new form (id={new_form.id})&#34;)
        except Exception as e:
            print(f&#34;[ERROR] Failed to copy questions: {e}&#34;)
            return JsonResponse({&#39;error&#39;: &#39;Failed to copy questions to the new form.&#39;}, status=500)

        # Return a success message
        return JsonResponse({&#39;message&#39;: f&#39;Successfully created a copy of the form: {new_form.name}.&#39;}, status=200)

    return JsonResponse({&#39;error&#39;: &#39;Invalid request method.&#39;}, status=405)</code></pre>
</details>
<div class="desc"><p>Create a duplicate of an existing Form (identified by <code>form_id</code>) along with all its questions,
allowing new metadata values for name, part number, and operation.</p>
<p>On POST:
1. Validates presence of <code>name</code>, <code>part_number</code>, and <code>operation</code> in <code>request.POST</code>.
2. Creates a new <code>Form</code> instance using the original form’s type and metadata,
overriding only the provided <code>part_number</code> and <code>operation</code> and setting the new <code>name</code>.
3. Copies each <code>FormQuestion</code> from the original form into the new form.
4. Returns a JSON success message with status 200.</p>
<p>On other methods:
- Returns a JSON error with status 405.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The incoming HTTP request. Must be POST to perform the copy.
form_id (int):
The primary key of the existing <code>Form</code> to duplicate.</p>
<h2 id="returns">Returns</h2>
<p>django.http.JsonResponse:
- On success (POST): <code>{'message': 'Successfully created a copy of the form: &lt;name&gt;.'}</code>, status=200.
- On missing fields: <code>{'error': 'All fields (name, part_number, operation) are required.'}</code>, status=400.
- On original form not found: <code>{'error': 'Original form not found.'}</code>, status=404.
- On creation or copy failure: appropriate <code>{'error': &lt;message&gt;}</code>, status=500.
- On non-POST requests: <code>{'error': 'Invalid request method.'}</code>, status=405.</p></div>
</dd>
<dt id="forms.views.find_and_tag_expired_questions"><code class="name flex">
<span>def <span class="ident">find_and_tag_expired_questions</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_and_tag_expired_questions():
    &#34;&#34;&#34;Scan all FormQuestion entries and mark those past their expiry date.

    Iterates through every `FormQuestion` instance, reads the `question` JSON field
    for an `expiry_date` (ISO‐formatted string), and:
      - If `expiry_date` &lt; today, sets `question[&#39;expired&#39;] = True`.
      - Otherwise, ensures `question[&#39;expired&#39;] = False`.
    Invalid or missing `expiry_date` values are skipped. Each question with an
    updated flag is saved back to the database.

    Side Effects:
        Updates the `expired` key in the `question` JSONField of `FormQuestion`
        records and saves the model.

    Returns:
        None
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    Finds and tags all expired questions based on their expiry_date field.
    &#34;&#34;&#34;
    # Get the current date
    today = now().date()

    # Fetch all questions from the FormQuestion model
    questions = FormQuestion.objects.all()

    for question in questions:
        # Extract the JSON object
        question_data = question.question

        # Check if the expiry_date key exists in the JSON and is valid
        expiry_date_str = question_data.get(&#39;expiry_date&#39;)
        if expiry_date_str:
            try:
                # Parse the expiry_date from the JSON object
                expiry_date = datetime.date.fromisoformat(expiry_date_str)
                if expiry_date &lt; today:
                    # Tag the question as expired if the date is in the past
                    question_data[&#39;expired&#39;] = True
                else:
                    # Ensure the expired key is False if the expiry_date is valid and not expired
                    question_data[&#39;expired&#39;] = False
            except ValueError:
                # If the expiry_date is invalid, skip this question
                continue

            # Save the updated question data back to the model
            question.question = question_data
            question.save()</code></pre>
</details>
<div class="desc"><p>Scan all FormQuestion entries and mark those past their expiry date.</p>
<p>Iterates through every <code>FormQuestion</code> instance, reads the <code>question</code> JSON field
for an <code>expiry_date</code> (ISO‐formatted string), and:
- If <code>expiry_date</code> &lt; today, sets <code>question['expired'] = True</code>.
- Otherwise, ensures <code>question['expired'] = False</code>.
Invalid or missing <code>expiry_date</code> values are skipped. Each question with an
updated flag is saved back to the database.</p>
<p>Side Effects:
Updates the <code>expired</code> key in the <code>question</code> JSONField of <code>FormQuestion</code>
records and saves the model.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="forms.views.find_deleted_forms"><code class="name flex">
<span>def <span class="ident">find_deleted_forms</span></span>(<span>form_type_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_deleted_forms(form_type_id):
    &#34;&#34;&#34;
    Retrieve the IDs of all forms of a given type that have been marked as deleted.

    Queries the `Form` model for any instances whose `form_type_id` matches the
    provided value and whose `metadata.deleted` flag is `True`, then returns
    their primary key IDs.

    Args:
        form_type_id (int):
            The database ID of the form type whose deleted forms you want to find.

    Returns:
        List[int]:
            A list of integer IDs corresponding to `Form` instances that have
            `metadata.deleted == True`.

    Example:
        &gt;&gt;&gt; # Suppose forms with IDs 3, 7, and 9 are deleted for form type 2
        &gt;&gt;&gt; find_deleted_forms(2)
        [3, 7, 9]
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    Find and return the IDs of all forms for the specified form type
    that have &#39;deleted: true&#39; in their metadata.
    &#34;&#34;&#34;
    # Fetch all forms for the given form type that are marked as deleted
    deleted_forms = Form.objects.filter(
        form_type_id=form_type_id,
        metadata__deleted=True  # Filter forms with &#39;deleted: true&#39; in metadata
    )

    # Collect the IDs of the deleted forms
    deleted_form_ids = [form.id for form in deleted_forms]
    print(f&#34;[INFO] Deleted forms for form type {form_type_id}: {deleted_form_ids}&#34;)

    # Return the list of deleted form IDs
    return deleted_form_ids</code></pre>
</details>
<div class="desc"><p>Retrieve the IDs of all forms of a given type that have been marked as deleted.</p>
<p>Queries the <code>Form</code> model for any instances whose <code>form_type_id</code> matches the
provided value and whose <code>metadata.deleted</code> flag is <code>True</code>, then returns
their primary key IDs.</p>
<h2 id="args">Args</h2>
<p>form_type_id (int):
The database ID of the form type whose deleted forms you want to find.</p>
<h2 id="returns">Returns</h2>
<p>List[int]:
A list of integer IDs corresponding to <code>Form</code> instances that have
<code>metadata.deleted == True</code>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Suppose forms with IDs 3, 7, and 9 are deleted for form type 2
&gt;&gt;&gt; find_deleted_forms(2)
[3, 7, 9]
</code></pre></div>
</dd>
<dt id="forms.views.find_forms_view"><code class="name flex">
<span>def <span class="ident">find_forms_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_forms_view(request):
    &#34;&#34;&#34;
    Display a list of forms for a selected form type, excluding those marked as deleted,
    and pass along user permissions for rendering.

    This view will first tag any expired questions via `find_and_tag_expired_questions()`,
    then look for a `form_type` query parameter in the request. If provided, it will:

      1. Retrieve the corresponding `FormType` (404 if not found).
      2. Use `find_deleted_forms()` to get IDs of forms whose metadata has `deleted=True`.
      3. Query `Form` objects of that type, excluding deleted ones, ordered by newest first.
      4. Build the set of all metadata keys present across those forms.
      5. Determine whether the authenticated user belongs to the
         “LPA Managers” or “Quality Engineer” groups.
      6. Render `forms/find_forms.html` with:
         - `form_type`: the selected `FormType` instance
         - `forms`: the filtered &amp; ordered form queryset
         - `metadata_keys`: a set of all metadata keys
         - `is_lpa_manager`, `is_quality_engineer`, `is_authenticated`

    If no `form_type` is specified, it retrieves all `FormType` instances and renders
    `forms/select_form_type.html` with the same permission flags.

    Args:
        request (django.http.HttpRequest):
            The incoming HTTP request, possibly carrying a `form_type` GET parameter.

    Returns:
        django.http.HttpResponse:
            - If `form_type` is provided and valid, renders the form list template.
            - Otherwise, renders the form-type selection template.

    Raises:
        Http404:
            If a `form_type` ID is provided but does not correspond to any `FormType`.
    &#34;&#34;&#34;

    # Check and tag expired questions
    find_and_tag_expired_questions()

    # Get the form type ID from the request
    form_type_id = request.GET.get(&#39;form_type&#39;)

    if form_type_id:
        # Fetch the FormType object
        form_type = get_object_or_404(FormType, id=form_type_id)
        
        # Get the IDs of deleted forms
        deleted_form_ids = find_deleted_forms(form_type_id)

        # Fetch the forms of that form type, excluding deleted forms and ordering by created_at descending
        forms = Form.objects.filter(
            form_type_id=form_type_id
        ).exclude(id__in=deleted_form_ids).order_by(&#39;-created_at&#39;)
        
        # Gather all unique metadata keys across all forms for this form type
        metadata_keys = set()
        for form in forms:
            metadata_keys.update(form.metadata.keys())  # Assuming `metadata` is a dictionary

        # Check if the user is authenticated and part of the &#34;LPA Managers&#34; group
        is_lpa_manager = False
        if request.user.is_authenticated:
            is_lpa_manager = request.user.groups.filter(name=&#34;LPA Managers&#34;).exists()

        is_quality_engineer = False
        if request.user.is_authenticated:
            is_quality_engineer = request.user.groups.filter(name=&#34;Quality Engineer&#34;).exists()


        return render(request, &#39;forms/find_forms.html&#39;, {
            &#39;form_type&#39;: form_type,
            &#39;forms&#39;: forms,
            &#39;metadata_keys&#39;: metadata_keys,
            &#39;is_lpa_manager&#39;: is_lpa_manager,  # Pass this to the template
            &#39;is_quality_engineer&#39;: is_quality_engineer,
            &#39;is_authenticated&#39;: request.user.is_authenticated,  # Add this

        })

    # If no form type is selected, display the form type selection
    form_types = FormType.objects.all()

    # Check if the user is authenticated and part of the &#34;LPA Managers&#34; group
    is_lpa_manager = False
    if request.user.is_authenticated:
        is_lpa_manager = request.user.groups.filter(name=&#34;LPA Managers&#34;).exists()

    is_quality_engineer = False
    if request.user.is_authenticated:
        is_quality_engineer = request.user.groups.filter(name=&#34;Quality Engineer&#34;).exists()

    return render(request, &#39;forms/select_form_type.html&#39;, {
        &#39;form_types&#39;: form_types,
        &#39;is_lpa_manager&#39;: is_lpa_manager,  # Pass this to the template
        &#39;is_quality_engineer&#39;: is_quality_engineer,  # Pass this to the template
        &#39;is_authenticated&#39;: request.user.is_authenticated,  # Add this
    })</code></pre>
</details>
<div class="desc"><p>Display a list of forms for a selected form type, excluding those marked as deleted,
and pass along user permissions for rendering.</p>
<p>This view will first tag any expired questions via <code><a title="forms.views.find_and_tag_expired_questions" href="#forms.views.find_and_tag_expired_questions">find_and_tag_expired_questions()</a></code>,
then look for a <code>form_type</code> query parameter in the request. If provided, it will:</p>
<ol>
<li>Retrieve the corresponding <code>FormType</code> (404 if not found).</li>
<li>Use <code><a title="forms.views.find_deleted_forms" href="#forms.views.find_deleted_forms">find_deleted_forms()</a></code> to get IDs of forms whose metadata has <code>deleted=True</code>.</li>
<li>Query <code>Form</code> objects of that type, excluding deleted ones, ordered by newest first.</li>
<li>Build the set of all metadata keys present across those forms.</li>
<li>Determine whether the authenticated user belongs to the
“LPA Managers” or “Quality Engineer” groups.</li>
<li>Render <code>forms/find_forms.html</code> with:<ul>
<li><code>form_type</code>: the selected <code>FormType</code> instance</li>
<li><code>forms</code>: the filtered &amp; ordered form queryset</li>
<li><code>metadata_keys</code>: a set of all metadata keys</li>
<li><code>is_lpa_manager</code>, <code>is_quality_engineer</code>, <code>is_authenticated</code></li>
</ul>
</li>
</ol>
<p>If no <code>form_type</code> is specified, it retrieves all <code>FormType</code> instances and renders
<code>forms/select_form_type.html</code> with the same permission flags.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The incoming HTTP request, possibly carrying a <code>form_type</code> GET parameter.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
- If <code>form_type</code> is provided and valid, renders the form list template.
- Otherwise, renders the form-type selection template.</p>
<h2 id="raises">Raises</h2>
<p>Http404:
If a <code>form_type</code> ID is provided but does not correspond to any <code>FormType</code>.</p></div>
</dd>
<dt id="forms.views.form_by_metadata_view"><code class="name flex">
<span>def <span class="ident">form_by_metadata_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def form_by_metadata_view(request):
    &#34;&#34;&#34;
    Lookup a Form by metadata and render its question answer interface, handling submissions.

    This view expects three GET parameters: `formtype`, `operation`, and `part_number`. If any
    are missing, it renders an error template. Otherwise, it retrieves the matching Form, selects
    the appropriate template and answer form class based on its FormType, filters out expired
    questions, and sorts them by their `order` metadata.

    On GET:
      - Reads an optional `machine` parameter.
      - Builds an empty formset pre-populated with each question for answer entry.
      - Renders the form template with `question_form_pairs`, any existing operator cookie, and no error.

    On POST:
      - Reads `operator_number` and `machine` from the POST data.
      - Captures a common timestamp for all submitted answers.
      - Validates the formset and operator; if valid, creates a `FormAnswer` for each answered question
        using the common timestamp, then redirects back to the same metadata-filtered URL.
      - If invalid or missing operator, re-renders the template with an error message.

    Args:
        request (django.http.HttpRequest):
            The HTTP request carrying metadata filters and, on POST, answer data.
    
    Returns:
        django.http.HttpResponse:
            - Renders the appropriate form template with question form pairs and context.
            - Redirects back to the metadata-filtered URL on successful submission.

    Raises:
        Http404:
            If no Form matches the provided `formtype`, `operation`, and `part_number`.
        ValueError:
            If the FormType’s name has no corresponding answer form class defined.
    &#34;&#34;&#34;
    # Extract query parameters
    form_type_id = request.GET.get(&#39;formtype&#39;)
    operation = request.GET.get(&#39;operation&#39;)
    part_number = request.GET.get(&#39;part_number&#39;)

    if not form_type_id or not operation or not part_number:
        return render(request, &#39;forms/error.html&#39;, {
            &#39;message&#39;: &#39;Missing query parameters. Please provide formtype, operation, and part_number.&#39;
        })

    form_instance = get_object_or_404(
        Form,
        form_type_id=form_type_id,
        metadata__operation=operation,
        metadata__part_number=part_number
    )

    form_type = form_instance.form_type
    template_name = f&#39;forms/{form_type.template_name}&#39;

    answer_form_classes = {
        &#39;OIS&#39;: OISAnswerForm,
        &#39;LPA&#39;: LPAAnswerForm,
    }
    answer_form_class = answer_form_classes.get(form_type.name)

    if not answer_form_class:
        raise ValueError(f&#34;No form class defined for form type: {form_type.name}&#34;)

    questions = sorted(
        form_instance.questions.filter(
            ~Q(question__has_key=&#39;expired&#39;) | Q(question__expired=False)
        ),
        key=lambda q: q.question.get(&#34;order&#34;, 0)
    )

    AnswerFormSet = modelformset_factory(FormAnswer, form=answer_form_class, extra=len(questions))
    initial_data = [{&#39;question&#39;: question} for question in questions]

    error_message = None
    operator_number = request.COOKIES.get(&#39;operator_number&#39;, &#39;&#39;)

    if request.method == &#39;POST&#39;:
        operator_number = request.POST.get(&#39;operator_number&#39;)
        machine = request.POST.get(&#39;machine&#39;, &#39;&#39;)

        # Capture the timestamp at the start of submission handling
        common_timestamp = timezone.now()

        formset = AnswerFormSet(
            request.POST,
            queryset=FormAnswer.objects.none(),
            form_kwargs={&#39;user&#39;: request.user, &#39;machine&#39;: machine}
        )

        if not operator_number:
            error_message = &#34;Operator number is required.&#34;
        else:
            if formset.is_valid():
                for i, form in enumerate(formset):
                    answer_data = form.cleaned_data.get(&#39;answer&#39;)
                    if answer_data:
                        # Manually set the common timestamp for all answers
                        FormAnswer.objects.create(
                            question=questions[i],
                            answer=answer_data,
                            operator_number=operator_number,
                            created_at=common_timestamp  # Same timestamp for all
                        )
                return redirect(f&#34;{request.path}?formtype={form_type_id}&amp;operation={operation}&amp;part_number={part_number}&#34;)
            else:
                error_message = &#34;There was an error with your submission.&#34;
    else:
        machine = request.GET.get(&#39;machine&#39;, &#39;&#39;)
        formset = AnswerFormSet(
            queryset=FormAnswer.objects.none(),
            initial=initial_data,
            form_kwargs={&#39;user&#39;: request.user, &#39;machine&#39;: machine}
        )

    question_form_pairs = zip(questions, formset.forms)

    return render(request, template_name, {
        &#39;form_instance&#39;: form_instance,
        &#39;question_form_pairs&#39;: question_form_pairs,
        &#39;formset&#39;: formset,
        &#39;error_message&#39;: error_message,
        &#39;operator_number&#39;: operator_number,
    })</code></pre>
</details>
<div class="desc"><p>Lookup a Form by metadata and render its question answer interface, handling submissions.</p>
<p>This view expects three GET parameters: <code>formtype</code>, <code>operation</code>, and <code>part_number</code>. If any
are missing, it renders an error template. Otherwise, it retrieves the matching Form, selects
the appropriate template and answer form class based on its FormType, filters out expired
questions, and sorts them by their <code>order</code> metadata.</p>
<p>On GET:
- Reads an optional <code>machine</code> parameter.
- Builds an empty formset pre-populated with each question for answer entry.
- Renders the form template with <code>question_form_pairs</code>, any existing operator cookie, and no error.</p>
<p>On POST:
- Reads <code>operator_number</code> and <code>machine</code> from the POST data.
- Captures a common timestamp for all submitted answers.
- Validates the formset and operator; if valid, creates a <code>FormAnswer</code> for each answered question
using the common timestamp, then redirects back to the same metadata-filtered URL.
- If invalid or missing operator, re-renders the template with an error message.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The HTTP request carrying metadata filters and, on POST, answer data.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
- Renders the appropriate form template with question form pairs and context.
- Redirects back to the metadata-filtered URL on successful submission.</p>
<h2 id="raises">Raises</h2>
<p>Http404:
If no Form matches the provided <code>formtype</code>, <code>operation</code>, and <code>part_number</code>.
ValueError:
If the FormType’s name has no corresponding answer form class defined.</p></div>
</dd>
<dt id="forms.views.form_create_view"><code class="name flex">
<span>def <span class="ident">form_create_view</span></span>(<span>request, form_id=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def form_create_view(request, form_id=None):
    &#34;&#34;&#34;Create or edit a Form and its associated questions.

    - If `form_id` is provided, loads the existing `Form` instance for editing.
    - Otherwise, reads `form_type` from `request.GET` and, if present, selects that type.
    - Dynamically looks up the corresponding Django `Form` class and question formset class.
    - On GET: renders the form and a formset of non‐expired questions (ordered by JSON `order`).
    - On POST: validates and saves the main form, then iterates the question formset:
        - Saves or updates each question, skipping those marked `DELETE`.
        - Deletes any existing question instance flagged for removal.
      Redirects to the edit view on success.
    - If no valid `form_type` is specified, renders a type‐selection page.
    - If the `form_type` has no registered form classes, renders an error template.

    Args:
        request (HttpRequest): The incoming HTTP request (GET or POST).
        form_id (int, optional): Primary key of an existing `Form` to edit; if omitted, creates a new `Form`.

    Returns:
        HttpResponse: 
            - On success: redirect to `&#39;form_edit&#39;` for the saved `Form`.
            - On GET or invalid POST: rendered template `&#39;forms/form_create.html&#39;` or `&#39;forms/select_form_type.html&#39;`.
    &#34;&#34;&#34;
    form_instance = None
    form_type = None
    if form_id:
        # Fetch the existing form to edit
        form_instance = get_object_or_404(Form, id=form_id)
        form_type = form_instance.form_type
    else:
        # Fetch the form type from the request for new forms
        form_type_id = request.GET.get(&#39;form_type&#39;)
        if form_type_id:
            form_type = get_object_or_404(FormType, id=form_type_id)

    if form_type:
        # Dynamically get the form class for the form type
        form_class = FORM_TYPE_FORMS.get(form_type.name)
        question_form_class = QUESTION_FORM_CLASSES.get(form_type.name)

        if form_class is None or question_form_class is None:
            return render(request, &#39;forms/error.html&#39;, {&#39;message&#39;: &#39;Form type not supported.&#39;})

        # Create a dynamic formset for questions
        QuestionFormSet = modelformset_factory(
            FormQuestion,
            form=question_form_class,
            extra=0,  # Set extra to 0 to prevent empty forms unless added by the user
            can_delete=True  # Allow deletion of forms
        )

        if request.method == &#39;POST&#39;:
            form = form_class(request.POST, instance=form_instance)
            question_formset = QuestionFormSet(
                request.POST,
                queryset=form_instance.questions.filter(
                    ~Q(question__has_key=&#39;expired&#39;) | Q(question__expired=False)  # Exclude expired questions
                ).order_by(&#39;question__order&#39;) if form_instance else FormQuestion.objects.none()
            )

            if form.is_valid() and question_formset.is_valid():
                form_instance = form.save()

                # Save each question in the formset
                for index, question_form in enumerate(question_formset.forms, start=1):
                    if question_form.cleaned_data and not question_form.cleaned_data.get(&#39;DELETE&#39;, False):
                        question_form.save(form_instance=form_instance, order=index)
                    elif question_form.cleaned_data.get(&#39;DELETE&#39;, False) and question_form.instance.pk:
                        # If the form is marked for deletion and exists in the DB, delete it
                        question_form.instance.delete()

                return redirect(&#39;form_edit&#39;, form_id=form_instance.id)  # Redirect after saving

        else:
            # Fetch questions ordered by the &#39;order&#39; field in the JSON, excluding expired
            form = form_class(instance=form_instance)
            question_formset = QuestionFormSet(
                queryset=form_instance.questions.filter(
                    ~Q(question__has_key=&#39;expired&#39;) | Q(question__expired=False)  # Exclude expired questions
                ).order_by(&#39;question__order&#39;) if form_instance else FormQuestion.objects.none()
            )

        # Pass `form_instance` to the template
        return render(request, &#39;forms/form_create.html&#39;, {
            &#39;form&#39;: form,
            &#39;question_formset&#39;: question_formset,
            &#39;form_type&#39;: form_type,
            &#39;original_form&#39;: form_instance,  # Ensure this is passed to the template
        })

    # If no form_type is provided, show a page to select the form type
    form_types = FormType.objects.all()
    return render(request, &#39;forms/select_form_type.html&#39;, {&#39;form_types&#39;: form_types})</code></pre>
</details>
<div class="desc"><p>Create or edit a Form and its associated questions.</p>
<ul>
<li>If <code>form_id</code> is provided, loads the existing <code>Form</code> instance for editing.</li>
<li>Otherwise, reads <code>form_type</code> from <code>request.GET</code> and, if present, selects that type.</li>
<li>Dynamically looks up the corresponding Django <code>Form</code> class and question formset class.</li>
<li>On GET: renders the form and a formset of non‐expired questions (ordered by JSON <code>order</code>).</li>
<li>On POST: validates and saves the main form, then iterates the question formset:<ul>
<li>Saves or updates each question, skipping those marked <code>DELETE</code>.</li>
<li>Deletes any existing question instance flagged for removal.
Redirects to the edit view on success.</li>
</ul>
</li>
<li>If no valid <code>form_type</code> is specified, renders a type‐selection page.</li>
<li>If the <code>form_type</code> has no registered form classes, renders an error template.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>HttpRequest</code></dt>
<dd>The incoming HTTP request (GET or POST).</dd>
<dt><strong><code>form_id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Primary key of an existing <code>Form</code> to edit; if omitted, creates a new <code>Form</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>HttpResponse</code></dt>
<dd>
<ul>
<li>On success: redirect to <code>'form_edit'</code> for the saved <code>Form</code>.</li>
<li>On GET or invalid POST: rendered template <code>'forms/form_create.html'</code> or <code>'forms/select_form_type.html'</code>.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="forms.views.form_questions_view"><code class="name flex">
<span>def <span class="ident">form_questions_view</span></span>(<span>request, form_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def form_questions_view(request, form_id):
    &#34;&#34;&#34;
    Display and process answer forms for a given Form instance.

    This view retrieves the specified Form by `form_id`, determines its
    template based on the associated FormType, and dynamically builds an
    answer formset for each question in the form. Questions are sorted
    by their `order` metadata. The operator number is persisted via cookie.
    On GET, it initializes blank answer forms; on POST, it validates and
    saves submitted answers, then redirects back to the same view.

    Args:
        request (django.http.HttpRequest):
            The incoming HTTP request, which may be GET or POST. On POST,
            must include `operator_number` and formset data.
        form_id (int):
            The primary key of the `Form` whose questions are to be answered.

    Returns:
        django.http.HttpResponse:
            - On GET: renders the form questions template specific to the
              FormType with an empty answer formset.
            - On POST with valid data: saves answers and redirects back.
            - On POST with missing operator number or invalid formset:
              re-renders the template with error messages.

    Raises:
        Http404:
            If no `Form` exists with the given `form_id`.
        ValueError:
            If the FormType’s name is not mapped to an answer form class.
    &#34;&#34;&#34;
    # Get the form instance and its form type
    form_instance = get_object_or_404(Form, id=form_id)
    form_type = form_instance.form_type

    # Debug print to check form instance and type
    print(f&#34;[DEBUG] Form instance: {form_instance}, Form type: {form_type}&#34;)

    # Determine the template to render based on the form type&#39;s template name
    template_name = f&#39;forms/{form_type.template_name}&#39;

    # Map form types to their respective form classes
    answer_form_classes = {
        &#39;OIS&#39;: OISAnswerForm,
        &#39;LPA&#39;: LPAAnswerForm,
        # Add more form types as needed
    }

    # Get the form class for the current form type
    answer_form_class = answer_form_classes.get(form_type.name)
    if not answer_form_class:
        raise ValueError(f&#34;No form class defined for form type: {form_type.name}&#34;)

    # Debug print to check selected form class
    # print(f&#34;[DEBUG] Selected form class: {answer_form_class}&#34;)

    # Sort questions by the &#34;order&#34; key in the question JSON field directly
    questions = sorted(
        form_instance.questions.all(),
        key=lambda q: q.question.get(&#34;order&#34;, 0)  # Access the &#39;order&#39; directly from the dictionary
    )

    # Debug print to check the number of questions
    # print(f&#34;[DEBUG] Number of questions: {len(questions)}&#34;)

    # Prepare formset for submitting answers, initializing with the number of questions
    AnswerFormSet = modelformset_factory(FormAnswer, form=answer_form_class, extra=len(questions))

    # Prepare initial data for each question
    initial_data = [{&#39;question&#39;: question} for question in questions]

    error_message = None  # Initialize error message variable

    # Retrieve the operator number from cookies
    operator_number = request.COOKIES.get(&#39;operator_number&#39;, &#39;&#39;)

    # Debug print to check operator number
    # print(f&#34;[DEBUG] Operator number from cookies: {operator_number}&#34;)

    if request.method == &#39;POST&#39;:
        operator_number = request.POST.get(&#39;operator_number&#39;)

        # Debug print to check operator number from POST
        # print(f&#34;[DEBUG] Operator number from POST: {operator_number}&#34;)

        if not operator_number:
            error_message = &#34;Operator number is required.&#34;
            formset = AnswerFormSet(
                request.POST, 
                queryset=FormAnswer.objects.none(), 
                form_kwargs={&#39;user&#39;: request.user}  # Pass user to forms
            )
        else:
            # Set the operator number as a cookie to persist it
            response = redirect(&#39;form_questions&#39;, form_id=form_instance.id)
            response.set_cookie(&#39;operator_number&#39;, operator_number, expires=datetime.datetime.now() + datetime.timedelta(days=365))

            # Initialize formset with the posted data and pass the user
            formset = AnswerFormSet(
                request.POST, 
                queryset=FormAnswer.objects.none(), 
                form_kwargs={&#39;user&#39;: request.user}  # Pass user during POST
            )

            # Debug print to check if user is being passed to the formset
            # print(f&#34;[DEBUG] User passed to formset during POST: {request.user}&#34;)

            if formset.is_valid():
                for i, form in enumerate(formset):
                    answer_data = form.cleaned_data.get(&#39;answer&#39;)
                    if answer_data:
                        # Get the corresponding question
                        question = questions[i]

                        # Debug print to check answer data and operator number
                        # print(f&#34;[DEBUG] Answer data: {answer_data}, Operator number: {operator_number}&#34;)

                        # Create a new answer object including the operator number
                        FormAnswer.objects.create(
                            question=question,
                            answer=answer_data,
                            operator_number=operator_number  # Store the operator number
                        )
                return response
            else:
                error_message = &#34;There was an error with your submission. Please check your answers.&#34;
    else:
        # Generate a formset with initial data, setting up the answer options based on checkmark
        formset = AnswerFormSet(
            queryset=FormAnswer.objects.none(), 
            initial=initial_data, 
            form_kwargs={&#39;user&#39;: request.user}  # Pass user during GET
        )

        # Debug print to verify user is being passed during initialization
        # print(f&#34;[DEBUG] User passed to formset initialization: {request.user}&#34;)

        for form, question in zip(formset.forms, questions):
            form.__init__(question=question)  # Pass question to form for conditional field handling

    # Zip the questions and formset forms for paired rendering
    question_form_pairs = zip(questions, formset.forms)

    # Render the template
    return render(request, template_name, {
        &#39;form_instance&#39;: form_instance,
        &#39;question_form_pairs&#39;: question_form_pairs,
        &#39;formset&#39;: formset,
        &#39;error_message&#39;: error_message,
        &#39;operator_number&#39;: operator_number,  # Pass the operator number to the template
    })</code></pre>
</details>
<div class="desc"><p>Display and process answer forms for a given Form instance.</p>
<p>This view retrieves the specified Form by <code>form_id</code>, determines its
template based on the associated FormType, and dynamically builds an
answer formset for each question in the form. Questions are sorted
by their <code>order</code> metadata. The operator number is persisted via cookie.
On GET, it initializes blank answer forms; on POST, it validates and
saves submitted answers, then redirects back to the same view.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The incoming HTTP request, which may be GET or POST. On POST,
must include <code>operator_number</code> and formset data.
form_id (int):
The primary key of the <code>Form</code> whose questions are to be answered.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
- On GET: renders the form questions template specific to the
FormType with an empty answer formset.
- On POST with valid data: saves answers and redirects back.
- On POST with missing operator number or invalid formset:
re-renders the template with error messages.</p>
<h2 id="raises">Raises</h2>
<p>Http404:
If no <code>Form</code> exists with the given <code>form_id</code>.
ValueError:
If the FormType’s name is not mapped to an answer form class.</p></div>
</dd>
<dt id="forms.views.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(request):
    # Check if the user is logged in and belongs to the LPA Managers group
    is_lpa_manager = request.user.is_authenticated and request.user.groups.filter(name=&#34;LPA Managers&#34;).exists()

    return render(request, &#39;forms/index.html&#39;, {&#39;is_lpa_manager&#39;: is_lpa_manager})</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="forms.views.lpa_closeout_view"><code class="name flex">
<span>def <span class="ident">lpa_closeout_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lpa_closeout_view(request):
    &#34;&#34;&#34;
    Handle LPA closeout submissions and display outstanding LPA answers needing closeout.

    On POST:
      1. Retrieves `answer_id`, `closeout_notes`, and `closeout_date` from the form.
      2. Validates and parses `closeout_date` in YYYY-MM-DD format.
      3. If valid, loads the corresponding `FormAnswer`, updates its JSON `answer` field
         with `closed_out`, `closeout_date`, and optional `closeout_notes`, then saves.
      4. Redirects back to the same view to refresh the listing.

    On GET:
      1. Queries for all `FormAnswer` instances of form type ID 15 where
         `&#34;answer&#34;: &#34;No&#34;` and `&#34;closed_out&#34;: True` is not present.
      2. Passes these outstanding LPA answers to the `forms/lpa_closeout.html` template.

    Args:
        request (django.http.HttpRequest):
            The incoming HTTP request, either GET to list answers or POST to submit closeout data.

    Returns:
        django.http.HttpResponse:
            - On GET: renders `&#34;forms/lpa_closeout.html&#34;` with context `{&#39;lpa_answers&#39;: lpa_answers}`.
            - On POST: redirects to `&#39;lpa_closeout&#39;` (refreshing the page), regardless of success or invalid date.
    &#34;&#34;&#34;
    from datetime import datetime
    if request.method == &#39;POST&#39;:
        # Process closeout submission
        answer_id = request.POST.get(&#39;answer_id&#39;)
        closeout_notes = request.POST.get(&#39;closeout_notes&#39;, &#39;&#39;)
        closeout_date = request.POST.get(&#39;closeout_date&#39;, &#39;&#39;)

        # Validate closeout_date
        try:
            closeout_date_parsed = datetime.strptime(closeout_date, &#39;%Y-%m-%d&#39;) if closeout_date else None
        except ValueError:
            closeout_date_parsed = None

        if not closeout_date_parsed:
            return redirect(&#39;lpa_closeout&#39;)  # Invalid date, just refresh for now

        # Fetch the answer and update the JSON field
        try:
            answer = FormAnswer.objects.get(id=answer_id)
            updated_answer = answer.answer.copy()  # Create a copy of the JSON field
            updated_answer[&#39;closed_out&#39;] = True
            updated_answer[&#39;closeout_date&#39;] = closeout_date_parsed.strftime(&#39;%Y-%m-%d&#39;)  # Store the date
            if closeout_notes:
                updated_answer[&#39;closeout_notes&#39;] = closeout_notes
            answer.answer = updated_answer
            answer.save()
        except FormAnswer.DoesNotExist:
            pass  # Handle gracefully if answer is missing

        return redirect(&#39;lpa_closeout&#39;)  # Redirect to refresh the page

    # Filter answers where closed_out != true and answer is &#34;No&#34;
    lpa_answers = FormAnswer.objects.filter(
        Q(answer__contains={&#39;answer&#39;: &#39;No&#39;}) &amp; ~Q(answer__contains={&#39;closed_out&#39;: True}),
        question__form__form_type__id=15
    ).select_related(&#39;question__form__form_type&#39;)

    # Debug: Print data to check the backend response
    print(&#34;DEBUG: Fetched answers:&#34;)
    for answer in lpa_answers:
        print(
            f&#34;Answer ID: {answer.id}, Question ID: {answer.question.id}, &#34;
            f&#34;Question Text: {answer.question.question.get(&#39;question_text&#39;, &#39;N/A&#39;)}, &#34;
            f&#34;Form Name: {answer.question.form.name}, Answer Data: {answer.answer}&#34;
        )

    # Pass the filtered answers to the template
    context = {
        &#39;lpa_answers&#39;: lpa_answers
    }
    return render(request, &#39;forms/lpa_closeout.html&#39;, context)</code></pre>
</details>
<div class="desc"><p>Handle LPA closeout submissions and display outstanding LPA answers needing closeout.</p>
<p>On POST:
1. Retrieves <code>answer_id</code>, <code>closeout_notes</code>, and <code>closeout_date</code> from the form.
2. Validates and parses <code>closeout_date</code> in YYYY-MM-DD format.
3. If valid, loads the corresponding <code>FormAnswer</code>, updates its JSON <code>answer</code> field
with <code>closed_out</code>, <code>closeout_date</code>, and optional <code>closeout_notes</code>, then saves.
4. Redirects back to the same view to refresh the listing.</p>
<p>On GET:
1. Queries for all <code>FormAnswer</code> instances of form type ID 15 where
<code>"answer": "No"</code> and <code>"closed_out": True</code> is not present.
2. Passes these outstanding LPA answers to the <code>forms/lpa_closeout.html</code> template.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The incoming HTTP request, either GET to list answers or POST to submit closeout data.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
- On GET: renders <code>"forms/lpa_closeout.html"</code> with context <code>{'lpa_answers': lpa_answers}</code>.
- On POST: redirects to <code>'lpa_closeout'</code> (refreshing the page), regardless of success or invalid date.</p></div>
</dd>
<dt id="forms.views.na_answers_view"><code class="name flex">
<span>def <span class="ident">na_answers_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def na_answers_view(request):
    &#34;&#34;&#34;
    List and process &#34;N/A&#34; answers for LPA forms, allowing AJAX-driven marking as dealt.

    On GET:
      1. Calculates a three-year cutoff from now.
      2. Retrieves all FormAnswer records for form type ID 15 with `&#34;answer&#34;: &#34;N/A&#34;` and
         `created_at` within the last three years.
      3. Excludes questions containing certain substrings.
      4. Renders `forms/na_answers_list.html` with the filtered answers under `&#39;na_answers&#39;`.

    On POST:
      1. Reads `answer_id` from `request.POST`.
      2. Fetches the corresponding FormAnswer (404 if missing).
      3. If its `&#34;answer&#34;` field equals `&#34;N/A&#34;`, updates it to `&#34;N/A-Dealt&#34;` and saves.
      4. If the request is AJAX (`X-Requested-With: XMLHttpRequest`), returns
         `JsonResponse({&#34;status&#34;: &#34;success&#34;, &#34;message&#34;: &#34;Updated successfully!&#34;})`.
      5. Otherwise, redirects to the `&#34;na_answers_list&#34;` view.

    Args:
        request (django.http.HttpRequest):
            - GET: no parameters.
            - POST: expects `answer_id` in form data.

    Returns:
        django.http.HttpResponse:
            - GET: renders the list template with context `{&#39;na_answers&#39;: filtered_na_answers}`.
            - POST (AJAX): JSON success response.
            - POST (non-AJAX): redirect to `&#34;na_answers_list&#34;`.

    Raises:
        Http404:
            If a POST `answer_id` does not correspond to any FormAnswer.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        answer_id = request.POST.get(&#34;answer_id&#34;)
        form_answer = get_object_or_404(FormAnswer, id=answer_id)

        # Update the answer field from &#34;N/A&#34; to &#34;N/A-Dealt&#34;
        if form_answer.answer.get(&#34;answer&#34;) == &#34;N/A&#34;:
            form_answer.answer[&#34;answer&#34;] = &#34;N/A-Dealt&#34;
            form_answer.save(update_fields=[&#34;answer&#34;])

            # Handle AJAX response if needed
            if request.headers.get(&#39;X-Requested-With&#39;) == &#39;XMLHttpRequest&#39;:
                return JsonResponse({&#34;status&#34;: &#34;success&#34;, &#34;message&#34;: &#34;Updated successfully!&#34;})

        return redirect(&#34;na_answers_list&#34;)  # Redirect after POST

    # Define the date threshold (last 3 years)
    three_years_ago = now() - timedelta(days=3*365)  # Approximate 3 years

    # Fetch all answers marked as &#34;N/A&#34; from forms with form_type = 15, within last 3 years
    na_answers = (
        FormAnswer.objects
        .filter(
            answer__answer=&#34;N/A&#34;,
            question__form__form_type__id=15,
            created_at__gte=three_years_ago  # Only last 3 years
        )
        .select_related(&#34;question&#34;, &#34;question__form&#34;)  # Optimize DB queries
        .order_by(&#39;-id&#39;)
    )

    # Substrings to exclude
    substrings_to_exclude = [
        &#34;If a Quality alert is present, has it been signed by the Operator?&#34;,
        &#34;If the Process Sheet refers to any Special Characteristics&#34;
    ]

    filtered_na_answers = []

    for answer in na_answers:
        question_text = answer.question.question.get(&#34;question_text&#34;)  # Extract text from JSON field
        
        if question_text and any(substring in question_text for substring in substrings_to_exclude):
            print(f&#34;Removing question: {question_text}&#34;)
        else:
            filtered_na_answers.append(answer)

    # print(f&#34;Total questions removed: {len(na_answers) - len(filtered_na_answers)}&#34;)
    # print(f&#34;Total questions kept (last 3 years): {len(filtered_na_answers)}&#34;)

    return render(request, &#39;forms/na_answers_list.html&#39;, {&#39;na_answers&#39;: filtered_na_answers})</code></pre>
</details>
<div class="desc"><p>List and process "N/A" answers for LPA forms, allowing AJAX-driven marking as dealt.</p>
<p>On GET:
1. Calculates a three-year cutoff from now.
2. Retrieves all FormAnswer records for form type ID 15 with <code>"answer": "N/A"</code> and
<code>created_at</code> within the last three years.
3. Excludes questions containing certain substrings.
4. Renders <code>forms/na_answers_list.html</code> with the filtered answers under <code>'na_answers'</code>.</p>
<p>On POST:
1. Reads <code>answer_id</code> from <code>request.POST</code>.
2. Fetches the corresponding FormAnswer (404 if missing).
3. If its <code>"answer"</code> field equals <code>"N/A"</code>, updates it to <code>"N/A-Dealt"</code> and saves.
4. If the request is AJAX (<code>X-Requested-With: XMLHttpRequest</code>), returns
<code>JsonResponse({"status": "success", "message": "Updated successfully!"})</code>.
5. Otherwise, redirects to the <code>"na_answers_list"</code> view.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
- GET: no parameters.
- POST: expects <code>answer_id</code> in form data.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
- GET: renders the list template with context <code>{'na_answers': filtered_na_answers}</code>.
- POST (AJAX): JSON success response.
- POST (non-AJAX): redirect to <code>"na_answers_list"</code>.</p>
<h2 id="raises">Raises</h2>
<p>Http404:
If a POST <code>answer_id</code> does not correspond to any FormAnswer.</p></div>
</dd>
<dt id="forms.views.na_dealt_answers_view"><code class="name flex">
<span>def <span class="ident">na_dealt_answers_view</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def na_dealt_answers_view(request):
    &#34;&#34;&#34;
    Display answers previously marked as &#39;N/A-Dealt&#39; and allow recovering them back to &#39;N/A&#39;.

    On GET:
        1. Computes a cutoff of three years ago.
        2. Retrieves all FormAnswer instances for form type ID 15 where
           `&#34;answer&#34;: &#34;N/A-Dealt&#34;` and `created_at` is within the last three years.
        3. Optimizes query with `select_related` and orders by newest first.
        4. Renders `forms/na_dealt_answers_list.html` with context
           `{&#39;na_dealt_answers&#39;: na_dealt_answers}`.

    On POST:
        1. Reads `answer_id` from `request.POST`.
        2. Fetches the corresponding FormAnswer (404 if not found).
        3. If its `&#34;answer&#34;` value is `&#34;N/A-Dealt&#34;`, updates it to `&#34;N/A&#34;` and saves.
        4. If the request is AJAX (`X-Requested-With: XMLHttpRequest`), returns
           `JsonResponse({&#34;status&#34;: &#34;success&#34;, &#34;message&#34;: &#34;Recovered successfully!&#34;})`.
        5. Otherwise, redirects to the `&#34;na_dealt_answers_list&#34;` view.

    Args:
        request (django.http.HttpRequest):
            - GET: no parameters.
            - POST: expects `answer_id` in form data.

    Returns:
        django.http.HttpResponse or JsonResponse:
            - GET: renders the list template with the `na_dealt_answers` context.
            - POST (AJAX): JSON success response.
            - POST (non-AJAX): redirect to `&#34;na_dealt_answers_list&#34;`.

    Raises:
        Http404:
            If a POST `answer_id` does not correspond to any FormAnswer.
    &#34;&#34;&#34;
    &#34;&#34;&#34;View to list answers marked as &#39;N/A-Dealt&#39; and allow recovering them back to &#39;N/A&#39;.&#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        answer_id = request.POST.get(&#34;answer_id&#34;)
        form_answer = get_object_or_404(FormAnswer, id=answer_id)

        # Update the answer field from &#34;N/A-Dealt&#34; to &#34;N/A&#34;
        if form_answer.answer.get(&#34;answer&#34;) == &#34;N/A-Dealt&#34;:
            form_answer.answer[&#34;answer&#34;] = &#34;N/A&#34;
            form_answer.save(update_fields=[&#34;answer&#34;])

            # Handle AJAX response if needed
            if request.headers.get(&#39;X-Requested-With&#39;) == &#39;XMLHttpRequest&#39;:
                return JsonResponse({&#34;status&#34;: &#34;success&#34;, &#34;message&#34;: &#34;Recovered successfully!&#34;})

        return redirect(&#34;na_dealt_answers_list&#34;)  # Redirect after POST

    # Define the date threshold (last 3 years)
    three_years_ago = now() - timedelta(days=3*365)  # Approximate 3 years

    # Fetch all answers marked as &#34;N/A-Dealt&#34; from the last 3 years
    na_dealt_answers = (
        FormAnswer.objects
        .filter(
            answer__answer=&#34;N/A-Dealt&#34;,
            question__form__form_type__id=15,  # Ensure it&#39;s from form type 15
            created_at__gte=three_years_ago  # Limit to last 3 years
        )
        .select_related(&#34;question&#34;, &#34;question__form&#34;)  # Optimize DB queries
        .order_by(&#39;-id&#39;)
    )

    # print(f&#34;Total &#39;N/A-Dealt&#39; questions in the last 3 years: {na_dealt_answers.count()}&#34;)

    return render(request, &#39;forms/na_dealt_answers_list.html&#39;, {&#39;na_dealt_answers&#39;: na_dealt_answers})</code></pre>
</details>
<div class="desc"><p>Display answers previously marked as 'N/A-Dealt' and allow recovering them back to 'N/A'.</p>
<p>On GET:
1. Computes a cutoff of three years ago.
2. Retrieves all FormAnswer instances for form type ID 15 where
<code>"answer": "N/A-Dealt"</code> and <code>created_at</code> is within the last three years.
3. Optimizes query with <code>select_related</code> and orders by newest first.
4. Renders <code>forms/na_dealt_answers_list.html</code> with context
<code>{'na_dealt_answers': na_dealt_answers}</code>.</p>
<p>On POST:
1. Reads <code>answer_id</code> from <code>request.POST</code>.
2. Fetches the corresponding FormAnswer (404 if not found).
3. If its <code>"answer"</code> value is <code>"N/A-Dealt"</code>, updates it to <code>"N/A"</code> and saves.
4. If the request is AJAX (<code>X-Requested-With: XMLHttpRequest</code>), returns
<code>JsonResponse({"status": "success", "message": "Recovered successfully!"})</code>.
5. Otherwise, redirects to the <code>"na_dealt_answers_list"</code> view.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
- GET: no parameters.
- POST: expects <code>answer_id</code> in form data.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse or JsonResponse:
- GET: renders the list template with the <code>na_dealt_answers</code> context.
- POST (AJAX): JSON success response.
- POST (non-AJAX): redirect to <code>"na_dealt_answers_list"</code>.</p>
<h2 id="raises">Raises</h2>
<p>Http404:
If a POST <code>answer_id</code> does not correspond to any FormAnswer.</p></div>
</dd>
<dt id="forms.views.process_form_deletion"><code class="name flex">
<span>def <span class="ident">process_form_deletion</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def process_form_deletion(request):
    &#34;&#34;&#34;
    Mark a Form as deleted by setting its `metadata[&#39;deleted&#39;]` flag to True.

    This view handles AJAX POST requests to “soft delete” a form. It looks for
    a `form_id` in `request.POST`, retrieves the corresponding `Form`, updates
    its `metadata` JSON field with `&#34;deleted&#34;: True`, and saves. It returns a JSON
    response indicating success or an appropriate error.

    Args:
        request (django.http.HttpRequest):
            The incoming HTTP request. On POST expects a `form_id` parameter.
    
    Returns:
        django.http.JsonResponse:
            - 200: `{&#34;message&#34;: &#34;Form &lt;form_id&gt; marked as deleted successfully!&#34;}` on success.
            - 400: `{&#34;error&#34;: &#34;Form ID not provided.&#34;}` if `form_id` is missing.
            - 404: `{&#34;error&#34;: &#34;Form with ID &lt;form_id&gt; not found.&#34;}` if no matching Form exists.
            - 500: `{&#34;error&#34;: &#34;An error occurred while marking the form as deleted.&#34;}` for unexpected failures.
            - 400 for non-POST requests: `{&#34;error&#34;: &#34;Invalid request method.&#34;}`.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        form_id = request.POST.get(&#34;form_id&#34;)
        if not form_id:
            return JsonResponse({&#34;error&#34;: &#34;Form ID not provided.&#34;}, status=400)

        try:
            # Retrieve the form and update its metadata
            form = Form.objects.get(id=form_id)
            form.metadata[&#34;deleted&#34;] = True  # Add &#34;deleted&#34;: true to metadata
            form.save()  # Save changes
            print(f&#34;[DEBUG] Form {form_id} marked as deleted.&#34;)
            return JsonResponse({&#34;message&#34;: f&#34;Form {form_id} marked as deleted successfully!&#34;})
        except Form.DoesNotExist:
            print(f&#34;[ERROR] Form with ID {form_id} not found.&#34;)
            return JsonResponse({&#34;error&#34;: f&#34;Form with ID {form_id} not found.&#34;}, status=404)
        except Exception as e:
            print(f&#34;[ERROR] Unexpected error: {e}&#34;)
            return JsonResponse({&#34;error&#34;: &#34;An error occurred while marking the form as deleted.&#34;}, status=500)
    else:
        return JsonResponse({&#34;error&#34;: &#34;Invalid request method.&#34;}, status=400)</code></pre>
</details>
<div class="desc"><p>Mark a Form as deleted by setting its <code>metadata['deleted']</code> flag to True.</p>
<p>This view handles AJAX POST requests to “soft delete” a form. It looks for
a <code>form_id</code> in <code>request.POST</code>, retrieves the corresponding <code>Form</code>, updates
its <code>metadata</code> JSON field with <code>"deleted": True</code>, and saves. It returns a JSON
response indicating success or an appropriate error.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The incoming HTTP request. On POST expects a <code>form_id</code> parameter.</p>
<h2 id="returns">Returns</h2>
<p>django.http.JsonResponse:
- 200: <code>{"message": "Form &lt;form_id&gt; marked as deleted successfully!"}</code> on success.
- 400: <code>{"error": "Form ID not provided."}</code> if <code>form_id</code> is missing.
- 404: <code>{"error": "Form with ID &lt;form_id&gt; not found."}</code> if no matching Form exists.
- 500: <code>{"error": "An error occurred while marking the form as deleted."}</code> for unexpected failures.
- 400 for non-POST requests: <code>{"error": "Invalid request method."}</code>.</p></div>
</dd>
<dt id="forms.views.process_selected_forms"><code class="name flex">
<span>def <span class="ident">process_selected_forms</span></span>(<span>request)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@csrf_exempt
def process_selected_forms(request):
    &#34;&#34;&#34;
    Handle bulk addition of a custom question to one or more Forms via AJAX.

    This view supports:
      - POST: Accepts a list of `form_ids[]`, question parameters (`question_text`,
        `what_to_look_for`, `recommended_action`, `typed_answer`, `expiry_date`),
        and creates a new `FormQuestion` on each specified Form.
      - GET: Renders and returns the HTML for the question-creation modal form.

    Args:
        request (django.http.HttpRequest):
            - On POST: expects `form_ids[]` (one or comma-separated list), plus
              `question_text` (required), `what_to_look_for`, `recommended_action`,
              `typed_answer` (&#39;true&#39; or &#39;false&#39;), and `expiry_date` (YYYY-MM-DD or None).
            - On GET: no parameters; returns the rendered `LPAQuestionForm` HTML.

    Returns:
        django.http.JsonResponse:
            - POST:
                * 200: `{&#34;message&#34;: &#34;Question added successfully!&#34;, &#34;form_ids&#34;: [...]}` on success.
                * 400: `{&#34;error&#34;: &#34;No forms selected.&#34;}` or `{&#34;error&#34;: &#34;Question text is required.&#34;}`
                  for missing inputs.
                * 404: `{&#34;error&#34;: &#34;Form with ID &lt;id&gt; not found.&#34;}` if any form_id is invalid.
                * 500: `{&#34;error&#34;: &#34;Failed to create question for form &lt;id&gt;.&#34;}` on unexpected errors.
            - GET:
                * 200: `{&#34;form_html&#34;: &#34;&lt;rendered form markup&gt;&#34;}` for inclusion in a modal.
                * 400: `{&#34;error&#34;: &#34;Invalid request method&#34;}` for non-GET/POST methods.
    &#34;&#34;&#34;
    if request.method == &#34;POST&#34;:
        print(&#34;[DEBUG] Received POST request&#34;)

        # Get form IDs and split if necessary
        raw_form_ids = request.POST.getlist(&#39;form_ids[]&#39;)
        print(f&#34;[DEBUG] Raw form_ids: {raw_form_ids}&#34;)

        # Handle both single string and list cases
        form_ids = []
        for item in raw_form_ids:
            form_ids.extend(item.split(&#39;,&#39;))  # Split comma-separated strings into individual IDs

        print(f&#34;[DEBUG] Parsed form_ids: {form_ids}&#34;)

        question_text = request.POST.get(&#39;question_text&#39;, &#39;&#39;)
        what_to_look_for = request.POST.get(&#39;what_to_look_for&#39;, &#39;&#39;)
        recommended_action = request.POST.get(&#39;recommended_action&#39;, &#39;&#39;)
        typed_answer = request.POST.get(&#39;typed_answer&#39;, &#39;false&#39;) == &#39;true&#39;
        expiry_date = request.POST.get(&#39;expiry_date&#39;, None)

        print(f&#34;[DEBUG] question_text: {question_text}&#34;)
        print(f&#34;[DEBUG] what_to_look_for: {what_to_look_for}&#34;)
        print(f&#34;[DEBUG] recommended_action: {recommended_action}&#34;)
        print(f&#34;[DEBUG] typed_answer: {typed_answer}&#34;)
        print(f&#34;[DEBUG] expiry_date: {expiry_date}&#34;)

        # Ensure form IDs are provided
        if not form_ids:
            print(&#34;[ERROR] No form IDs provided&#34;)
            return JsonResponse({&#34;error&#34;: &#34;No forms selected.&#34;}, status=400)

        # Ensure the question text is provided
        if not question_text:
            print(&#34;[ERROR] No question text provided&#34;)
            return JsonResponse({&#34;error&#34;: &#34;Question text is required.&#34;}, status=400)

        # Add the question to each form
        for form_id in form_ids:
            try:
                form = Form.objects.get(id=form_id)
                print(f&#34;[DEBUG] Found form: {form}&#34;)

                # Create the new question
                question_data = {
                    &#39;question_text&#39;: question_text,
                    &#39;what_to_look_for&#39;: what_to_look_for,
                    &#39;recommended_action&#39;: recommended_action,
                    &#39;typed_answer&#39;: typed_answer,
                    &#39;expiry_date&#39;: expiry_date,
                }
                print(f&#34;[DEBUG] Creating question with data: {question_data}&#34;)
                FormQuestion.objects.create(
                    form=form,
                    question=question_data,
                )
                print(f&#34;[DEBUG] Question created for form {form_id}&#34;)

            except Form.DoesNotExist:
                print(f&#34;[ERROR] Form with ID {form_id} does not exist&#34;)
                return JsonResponse({&#34;error&#34;: f&#34;Form with ID {form_id} not found.&#34;}, status=404)
            except Exception as e:
                print(f&#34;[ERROR] Unexpected error while creating question for form {form_id}: {e}&#34;)
                return JsonResponse({&#34;error&#34;: f&#34;Failed to create question for form {form_id}.&#34;}, status=500)

        print(&#34;[DEBUG] All questions added successfully&#34;)
        return JsonResponse({&#34;message&#34;: &#34;Question added successfully!&#34;, &#34;form_ids&#34;: form_ids})

    elif request.method == &#34;GET&#34;:
        print(&#34;[DEBUG] Received GET request for modal form&#34;)
        form = LPAQuestionForm()  # Initialize the form
        form_html = render_to_string(
            &#34;forms/question_form.html&#34;,  # Template to render the form
            {&#34;form&#34;: form},
            request=request,
        )
        print(&#34;[DEBUG] Returning rendered form HTML&#34;)
        return JsonResponse({&#34;form_html&#34;: form_html})

    else:
        print(f&#34;[ERROR] Invalid request method: {request.method}&#34;)
        return JsonResponse({&#34;error&#34;: &#34;Invalid request method&#34;}, status=400)</code></pre>
</details>
<div class="desc"><p>Handle bulk addition of a custom question to one or more Forms via AJAX.</p>
<p>This view supports:
- POST: Accepts a list of <code>form_ids[]</code>, question parameters (<code>question_text</code>,
<code>what_to_look_for</code>, <code>recommended_action</code>, <code>typed_answer</code>, <code>expiry_date</code>),
and creates a new <code>FormQuestion</code> on each specified Form.
- GET: Renders and returns the HTML for the question-creation modal form.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
- On POST: expects <code>form_ids[]</code> (one or comma-separated list), plus
<code>question_text</code> (required), <code>what_to_look_for</code>, <code>recommended_action</code>,
<code>typed_answer</code> ('true' or 'false'), and <code>expiry_date</code> (YYYY-MM-DD or None).
- On GET: no parameters; returns the rendered <code>LPAQuestionForm</code> HTML.</p>
<h2 id="returns">Returns</h2>
<p>django.http.JsonResponse:
- POST:
* 200: <code>{"message": "Question added successfully!", "form_ids": [...]}</code> on success.
* 400: <code>{"error": "No forms selected."}</code> or <code>{"error": "Question text is required."}</code>
for missing inputs.
* 404: <code>{"error": "Form with ID &lt;id&gt; not found."}</code> if any form_id is invalid.
* 500: <code>{"error": "Failed to create question for form &lt;id&gt;."}</code> on unexpected errors.
- GET:
* 200: <code>{"form_html": "&lt;rendered form markup&gt;"}</code> for inclusion in a modal.
* 400: <code>{"error": "Invalid request method"}</code> for non-GET/POST methods.</p></div>
</dd>
<dt id="forms.views.smart_form_redirect_view"><code class="name flex">
<span>def <span class="ident">smart_form_redirect_view</span></span>(<span>request, form_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smart_form_redirect_view(request, form_id):
    &#34;&#34;&#34;
    Redirect to the appropriate form-answer interface based on metadata if possible.

    Retrieves the Form by `form_id`. If its metadata contains both `operation` and
    `part_number`, and a Form with the same form_type, operation, and part_number
    exists, redirects to the metadata-based URL (`form_by_metadata`). Otherwise,
    falls back to the standard ID-based questions view (`form_questions`).

    Args:
        request (django.http.HttpRequest):
            The incoming HTTP request.
        form_id (int):
            The primary key of the Form to inspect for metadata-based redirect.

    Returns:
        django.http.HttpResponseRedirect:
            A redirect to the metadata-filtered form URL if matching metadata is found,
            otherwise a redirect to the ID-based questions view.

    Raises:
        Http404:
            If no Form exists with the given `form_id`.
    &#34;&#34;&#34;
    form_instance = get_object_or_404(Form, id=form_id)
    
    form_type_id = form_instance.form_type_id
    operation = form_instance.metadata.get(&#39;operation&#39;)
    part_number = form_instance.metadata.get(&#39;part_number&#39;)
    
    # Only attempt metadata-based redirect if we have both operation &amp; part_number
    if operation and part_number:
        # Check if a matching Form actually exists. If it does, we redirect to metadata‐based URL
        try:
            Form.objects.get(
                form_type_id=form_type_id,
                metadata__operation=operation,
                metadata__part_number=part_number
            )
            # If we get here, a valid Form with that metadata exists
            querystring = f&#34;?formtype={form_type_id}&amp;operation={operation}&amp;part_number={part_number}&#34;
            return redirect(reverse(&#39;form_by_metadata&#39;) + querystring)
        except Form.DoesNotExist:
            pass
    
    # Fallback to the ID-based URL
    return redirect(&#39;form_questions&#39;, form_id=form_id)</code></pre>
</details>
<div class="desc"><p>Redirect to the appropriate form-answer interface based on metadata if possible.</p>
<p>Retrieves the Form by <code>form_id</code>. If its metadata contains both <code>operation</code> and
<code>part_number</code>, and a Form with the same form_type, operation, and part_number
exists, redirects to the metadata-based URL (<code>form_by_metadata</code>). Otherwise,
falls back to the standard ID-based questions view (<code>form_questions</code>).</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The incoming HTTP request.
form_id (int):
The primary key of the Form to inspect for metadata-based redirect.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponseRedirect:
A redirect to the metadata-filtered form URL if matching metadata is found,
otherwise a redirect to the ID-based questions view.</p>
<h2 id="raises">Raises</h2>
<p>Http404:
If no Form exists with the given <code>form_id</code>.</p></div>
</dd>
<dt id="forms.views.view_records"><code class="name flex">
<span>def <span class="ident">view_records</span></span>(<span>request, form_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_records(request, form_id):
    &#34;&#34;&#34;
    Display a timestamped table of all answers submitted for a given Form.

    This view retrieves the specified Form and its associated questions, then
    gathers every FormAnswer for each question. Each answer’s UTC timestamp
    is converted to EST (UTC–5), formatted as &#34;YYYY-MM-DD HH:MM&#34;, and used
    to group answers by submission. The most recent 48 unique submission
    timestamps (newest first) are selected as columns. The resulting data
    structure aligns each question (row) with its answer or a blank cell
    for each timestamp. Finally, the view renders `forms/view_records.html`
    with:
      - `form_instance`: the Form being viewed
      - `submission_timestamps`: list of EST-formatted timestamp strings
      - `submission_data`: list of dicts containing question metadata and
        aligned answer entries for rendering the table.

    Args:
        request (django.http.HttpRequest):
            The incoming HTTP request.
        form_id (int):
            The primary key of the `Form` whose answer history should be shown.

    Returns:
        django.http.HttpResponse:
            Renders the `forms/view_records.html` template populated with
            `form_instance`, `submission_timestamps`, and `submission_data`.

    Raises:
        Http404:
            If no `Form` exists with the given `form_id`.
    &#34;&#34;&#34;
    # Fetch the form instance and its questions
    form_instance = get_object_or_404(Form, id=form_id)
    questions = form_instance.questions.all()

    # Initialize a list for timestamps and the final data structure for table rows
    submission_timestamps = []
    submission_data = []

    # Collect unique timestamps and organize answers by feature
    answers_by_timestamp = defaultdict(lambda: defaultdict(lambda: None))
    for question in questions:
        for answer in question.answers.order_by(&#34;created_at&#34;):
            # Convert UTC datetime to EST by subtracting 5 hours
            utc_timestamp = answer.created_at
            est_timestamp = utc_timestamp - timedelta(hours=5)  # UTC to EST (UTC - 5)

            # Format the EST timestamp to &#34;YYYY-MM-DD HH:MM&#34;
            timestamp_str = est_timestamp.strftime(&#34;%Y-%m-%d %H:%M&#34;)

            # Track unique submission timestamps in order of creation
            if timestamp_str not in submission_timestamps:
                submission_timestamps.append(timestamp_str)
            
            # Map answer by question and timestamp
            answers_by_timestamp[question.id][timestamp_str] = {
                &#34;answer&#34;: answer.answer,
                &#34;created_at&#34;: est_timestamp,
            }

    # Reverse sort submission timestamps to display latest submissions first
    submission_timestamps.sort(reverse=True)

    # Limit to the 10 most recent timestamps
    submission_timestamps = submission_timestamps[:48]

    # Prepare each question record for display
    for question in questions:
        row_data = {
            &#34;feature&#34;: question.question.get(&#34;feature&#34;, &#34;N/A&#34;),
            &#34;characteristic&#34;: question.question.get(&#34;characteristic&#34;, &#34;N/A&#34;),
            &#34;answers&#34;: []
        }

        # Fill in answers for each submission timestamp, aligned with the correct column
        for timestamp in submission_timestamps:
            if timestamp in answers_by_timestamp[question.id]:
                answer_data = answers_by_timestamp[question.id][timestamp]
                row_data[&#34;answers&#34;].append({
                    &#34;answer&#34;: answer_data[&#34;answer&#34;],
                    &#34;created_at&#34;: answer_data[&#34;created_at&#34;],
                    &#34;blank&#34;: False  # Not blank if there&#39;s an answer
                })
            else:
                # Mark missing answers as blank
                row_data[&#34;answers&#34;].append({&#34;blank&#34;: True})

        submission_data.append(row_data)

    return render(request, &#39;forms/view_records.html&#39;, {
        &#34;form_instance&#34;: form_instance,
        &#34;submission_timestamps&#34;: submission_timestamps,
        &#34;submission_data&#34;: submission_data,
    })</code></pre>
</details>
<div class="desc"><p>Display a timestamped table of all answers submitted for a given Form.</p>
<p>This view retrieves the specified Form and its associated questions, then
gathers every FormAnswer for each question. Each answer’s UTC timestamp
is converted to EST (UTC–5), formatted as "YYYY-MM-DD HH:MM", and used
to group answers by submission. The most recent 48 unique submission
timestamps (newest first) are selected as columns. The resulting data
structure aligns each question (row) with its answer or a blank cell
for each timestamp. Finally, the view renders <code>forms/view_records.html</code>
with:
- <code>form_instance</code>: the Form being viewed
- <code>submission_timestamps</code>: list of EST-formatted timestamp strings
- <code>submission_data</code>: list of dicts containing question metadata and
aligned answer entries for rendering the table.</p>
<h2 id="args">Args</h2>
<p>request (django.http.HttpRequest):
The incoming HTTP request.
form_id (int):
The primary key of the <code>Form</code> whose answer history should be shown.</p>
<h2 id="returns">Returns</h2>
<p>django.http.HttpResponse:
Renders the <code>forms/view_records.html</code> template populated with
<code>form_instance</code>, <code>submission_timestamps</code>, and <code>submission_data</code>.</p>
<h2 id="raises">Raises</h2>
<p>Http404:
If no <code>Form</code> exists with the given <code>form_id</code>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="forms.views.FormTypeCreateView"><code class="flex name class">
<span>class <span class="ident">FormTypeCreateView</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormTypeCreateView(CreateView):
    model = FormType
    fields = [&#39;name&#39;, &#39;template_name&#39;]
    template_name = &#39;forms/formtypes/formtype_form.html&#39;
    success_url = reverse_lazy(&#39;formtype_list&#39;)</code></pre>
</details>
<div class="desc"><p>View for creating a new object, with a response rendered by a template.</p>
<p>Constructor. Called in the URLconf; can contain helpful extra
keyword arguments, and other things.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>django.views.generic.edit.CreateView</li>
<li>django.views.generic.detail.SingleObjectTemplateResponseMixin</li>
<li>django.views.generic.base.TemplateResponseMixin</li>
<li>django.views.generic.edit.BaseCreateView</li>
<li>django.views.generic.edit.ModelFormMixin</li>
<li>django.views.generic.edit.FormMixin</li>
<li>django.views.generic.detail.SingleObjectMixin</li>
<li>django.views.generic.base.ContextMixin</li>
<li>django.views.generic.edit.ProcessFormView</li>
<li>django.views.generic.base.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forms.views.FormTypeCreateView.fields"><code class="name">var <span class="ident">fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forms.views.FormTypeCreateView.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"><p>Represents a category of form, defining its display name and the template
used to render instances of this form type.</p>
<h2 id="attributes">Attributes</h2>
<p>name (str):
The human-readable name of this form type.
template_name (str):
The filename (within the <code>forms/</code> templates directory) used to
render forms of this type.</p></div>
</dd>
<dt id="forms.views.FormTypeCreateView.success_url"><code class="name">var <span class="ident">success_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forms.views.FormTypeCreateView.template_name"><code class="name">var <span class="ident">template_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="forms.views.FormTypeDeleteView"><code class="flex name class">
<span>class <span class="ident">FormTypeDeleteView</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormTypeDeleteView(DeleteView):
    model = FormType
    template_name = &#39;forms/formtypes/formtype_confirm_delete.html&#39;
    success_url = reverse_lazy(&#39;formtype_list&#39;)</code></pre>
</details>
<div class="desc"><p>View for deleting an object retrieved with self.get_object(), with a
response rendered by a template.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>django.views.generic.edit.DeleteView</li>
<li>django.views.generic.detail.SingleObjectTemplateResponseMixin</li>
<li>django.views.generic.base.TemplateResponseMixin</li>
<li>django.views.generic.edit.BaseDeleteView</li>
<li>django.views.generic.edit.DeletionMixin</li>
<li>django.views.generic.edit.FormMixin</li>
<li>django.views.generic.detail.BaseDetailView</li>
<li>django.views.generic.detail.SingleObjectMixin</li>
<li>django.views.generic.base.ContextMixin</li>
<li>django.views.generic.base.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forms.views.FormTypeDeleteView.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"><p>Represents a category of form, defining its display name and the template
used to render instances of this form type.</p>
<h2 id="attributes">Attributes</h2>
<p>name (str):
The human-readable name of this form type.
template_name (str):
The filename (within the <code>forms/</code> templates directory) used to
render forms of this type.</p></div>
</dd>
<dt id="forms.views.FormTypeDeleteView.success_url"><code class="name">var <span class="ident">success_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forms.views.FormTypeDeleteView.template_name"><code class="name">var <span class="ident">template_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="forms.views.FormTypeListView"><code class="flex name class">
<span>class <span class="ident">FormTypeListView</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormTypeListView(ListView):
    model = FormType
    template_name = &#39;forms/formtypes/formtype_list.html&#39;
    context_object_name = &#39;formtypes&#39;</code></pre>
</details>
<div class="desc"><p>Render some list of objects, set by <code>self.model</code> or <code>self.queryset</code>.
<code>self.queryset</code> can actually be any iterable of items, not just a queryset.</p>
<p>Constructor. Called in the URLconf; can contain helpful extra
keyword arguments, and other things.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>django.views.generic.list.ListView</li>
<li>django.views.generic.list.MultipleObjectTemplateResponseMixin</li>
<li>django.views.generic.base.TemplateResponseMixin</li>
<li>django.views.generic.list.BaseListView</li>
<li>django.views.generic.list.MultipleObjectMixin</li>
<li>django.views.generic.base.ContextMixin</li>
<li>django.views.generic.base.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forms.views.FormTypeListView.context_object_name"><code class="name">var <span class="ident">context_object_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forms.views.FormTypeListView.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"><p>Represents a category of form, defining its display name and the template
used to render instances of this form type.</p>
<h2 id="attributes">Attributes</h2>
<p>name (str):
The human-readable name of this form type.
template_name (str):
The filename (within the <code>forms/</code> templates directory) used to
render forms of this type.</p></div>
</dd>
<dt id="forms.views.FormTypeListView.template_name"><code class="name">var <span class="ident">template_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="forms.views.FormTypeUpdateView"><code class="flex name class">
<span>class <span class="ident">FormTypeUpdateView</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormTypeUpdateView(UpdateView):
    model = FormType
    fields = [&#39;name&#39;, &#39;template_name&#39;]
    template_name = &#39;forms/formtypes/formtype_form.html&#39;
    success_url = reverse_lazy(&#39;formtype_list&#39;)</code></pre>
</details>
<div class="desc"><p>View for updating an object, with a response rendered by a template.</p>
<p>Constructor. Called in the URLconf; can contain helpful extra
keyword arguments, and other things.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>django.views.generic.edit.UpdateView</li>
<li>django.views.generic.detail.SingleObjectTemplateResponseMixin</li>
<li>django.views.generic.base.TemplateResponseMixin</li>
<li>django.views.generic.edit.BaseUpdateView</li>
<li>django.views.generic.edit.ModelFormMixin</li>
<li>django.views.generic.edit.FormMixin</li>
<li>django.views.generic.detail.SingleObjectMixin</li>
<li>django.views.generic.base.ContextMixin</li>
<li>django.views.generic.edit.ProcessFormView</li>
<li>django.views.generic.base.View</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forms.views.FormTypeUpdateView.fields"><code class="name">var <span class="ident">fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forms.views.FormTypeUpdateView.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"><p>Represents a category of form, defining its display name and the template
used to render instances of this form type.</p>
<h2 id="attributes">Attributes</h2>
<p>name (str):
The human-readable name of this form type.
template_name (str):
The filename (within the <code>forms/</code> templates directory) used to
render forms of this type.</p></div>
</dd>
<dt id="forms.views.FormTypeUpdateView.success_url"><code class="name">var <span class="ident">success_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forms.views.FormTypeUpdateView.template_name"><code class="name">var <span class="ident">template_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="forms.views.bulk_form_and_question_create_view" href="#forms.views.bulk_form_and_question_create_view">bulk_form_and_question_create_view</a></code></li>
<li><code><a title="forms.views.closed_lpas_view" href="#forms.views.closed_lpas_view">closed_lpas_view</a></code></li>
<li><code><a title="forms.views.create_form_copy_view" href="#forms.views.create_form_copy_view">create_form_copy_view</a></code></li>
<li><code><a title="forms.views.find_and_tag_expired_questions" href="#forms.views.find_and_tag_expired_questions">find_and_tag_expired_questions</a></code></li>
<li><code><a title="forms.views.find_deleted_forms" href="#forms.views.find_deleted_forms">find_deleted_forms</a></code></li>
<li><code><a title="forms.views.find_forms_view" href="#forms.views.find_forms_view">find_forms_view</a></code></li>
<li><code><a title="forms.views.form_by_metadata_view" href="#forms.views.form_by_metadata_view">form_by_metadata_view</a></code></li>
<li><code><a title="forms.views.form_create_view" href="#forms.views.form_create_view">form_create_view</a></code></li>
<li><code><a title="forms.views.form_questions_view" href="#forms.views.form_questions_view">form_questions_view</a></code></li>
<li><code><a title="forms.views.index" href="#forms.views.index">index</a></code></li>
<li><code><a title="forms.views.lpa_closeout_view" href="#forms.views.lpa_closeout_view">lpa_closeout_view</a></code></li>
<li><code><a title="forms.views.na_answers_view" href="#forms.views.na_answers_view">na_answers_view</a></code></li>
<li><code><a title="forms.views.na_dealt_answers_view" href="#forms.views.na_dealt_answers_view">na_dealt_answers_view</a></code></li>
<li><code><a title="forms.views.process_form_deletion" href="#forms.views.process_form_deletion">process_form_deletion</a></code></li>
<li><code><a title="forms.views.process_selected_forms" href="#forms.views.process_selected_forms">process_selected_forms</a></code></li>
<li><code><a title="forms.views.smart_form_redirect_view" href="#forms.views.smart_form_redirect_view">smart_form_redirect_view</a></code></li>
<li><code><a title="forms.views.view_records" href="#forms.views.view_records">view_records</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="forms.views.FormTypeCreateView" href="#forms.views.FormTypeCreateView">FormTypeCreateView</a></code></h4>
<ul class="">
<li><code><a title="forms.views.FormTypeCreateView.fields" href="#forms.views.FormTypeCreateView.fields">fields</a></code></li>
<li><code><a title="forms.views.FormTypeCreateView.model" href="#forms.views.FormTypeCreateView.model">model</a></code></li>
<li><code><a title="forms.views.FormTypeCreateView.success_url" href="#forms.views.FormTypeCreateView.success_url">success_url</a></code></li>
<li><code><a title="forms.views.FormTypeCreateView.template_name" href="#forms.views.FormTypeCreateView.template_name">template_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forms.views.FormTypeDeleteView" href="#forms.views.FormTypeDeleteView">FormTypeDeleteView</a></code></h4>
<ul class="">
<li><code><a title="forms.views.FormTypeDeleteView.model" href="#forms.views.FormTypeDeleteView.model">model</a></code></li>
<li><code><a title="forms.views.FormTypeDeleteView.success_url" href="#forms.views.FormTypeDeleteView.success_url">success_url</a></code></li>
<li><code><a title="forms.views.FormTypeDeleteView.template_name" href="#forms.views.FormTypeDeleteView.template_name">template_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forms.views.FormTypeListView" href="#forms.views.FormTypeListView">FormTypeListView</a></code></h4>
<ul class="">
<li><code><a title="forms.views.FormTypeListView.context_object_name" href="#forms.views.FormTypeListView.context_object_name">context_object_name</a></code></li>
<li><code><a title="forms.views.FormTypeListView.model" href="#forms.views.FormTypeListView.model">model</a></code></li>
<li><code><a title="forms.views.FormTypeListView.template_name" href="#forms.views.FormTypeListView.template_name">template_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forms.views.FormTypeUpdateView" href="#forms.views.FormTypeUpdateView">FormTypeUpdateView</a></code></h4>
<ul class="">
<li><code><a title="forms.views.FormTypeUpdateView.fields" href="#forms.views.FormTypeUpdateView.fields">fields</a></code></li>
<li><code><a title="forms.views.FormTypeUpdateView.model" href="#forms.views.FormTypeUpdateView.model">model</a></code></li>
<li><code><a title="forms.views.FormTypeUpdateView.success_url" href="#forms.views.FormTypeUpdateView.success_url">success_url</a></code></li>
<li><code><a title="forms.views.FormTypeUpdateView.template_name" href="#forms.views.FormTypeUpdateView.template_name">template_name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
